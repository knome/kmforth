
# region format
# 
# [ header ] 
# [ roots , ... ]
# [ ... , data  ]
# 
# [ givenSize  qword ] # what size the user requested
# [ actualSize qword ] # what size of the user request we could actually use ( clipped to nearest page )
# [ totalPages qword ] # how many pages does the memory arena have to play with?
# [ nRoots     qword ] # how many roots were requested for the arena?
# [ nObjects   qword ] # how many objects are currently in the arena?

# a gcref has two parts
#   64bits
#     19bits : root-index
#     45bits : arena-pointer
#   in this way, we can save and move references to arena data easily in kmforth's stack values
#   right now, we'll need to manually clear gc roots to release data
#   we could alter things to do stack scans in the future to be able to automatically collect lost roots as well
#   but not in the first version

% gc/-header (@rc @st)
  @ @rc @st (
    (givenSize     type/u64)
    (actualSize    type/u64)
    (totalPages    type/u64)
    (sizeInSlots   type/u64)
    (nRoots        type/u32)
    (nObjects      type/u32)
    (nextFreeIndex type/u32)
  );
;

% gc/-entry (@rc @st)
  @ @rc @st (
    (typeIndex     type/u32)
    (sizeInEntries type/u32)
    (data          type/u64)
  );
;

% gc/-location (@rc @st)
  @ @rc @st (
    (dataIndex type/u32)
    (dataSize  type/u32)
  );
;

@ struct/define gc/-header   ;
@ struct/define gc/-entry    ;
@ struct/define gc/-location ;

:gc/-pagesize 4096 ;

# [: size
# [: arena
# 
:gc/arena { $size $actual $totalPages }
  
  dup $size.set                                                   # [: size
  
  gc/-pagesize 3 * <                                              # [: (size<pagesize*3)
  dup                                                             # [: (size<pagesize*3) (size<pagesize*3)
  [ 0 swap "arenas must be at least three pages of memory" swap ] # [: (size<pagesize*3) (size<pagesize*3) diefn
  $.callIf                                                        # [: (size<pagesize*3) | 0 errmsg (size<pagesize*3) {oncalled}
  $.leaveIf                                                       # [: | 0 errmsg {leaving}
  
  $size.get dup gc/-pagesize % - $actual.set                      # determine how much actual memory we'll be using
  $actual.get gc/-pagesize / $totalPages.set                      # figure out how many pages that is
  
  $actual.get memory/map-region                                   # [: buffer err
  dup $.leaveIf                                                   # [: buffer err ( on error leaves with [: <trash> err
  pop                                                             # [: buffer
  
  dup $size.get       gc/-header//givenSize.set                   # [: buffer
  dup $actual.get     gc/-header//actualSize.set                  # [: buffer
  dup $totalPages.get gc/-header//totalPages.set                  # [: buffer
  dup 0               gc/-header//nRoots.set                      # [: buffer
  dup 0               gc/-header//nObjects.set                    # [: buffer
  
  0                                                               # [: buffer err=0
;

# [: arena rootId size
# [: gcref
# 
:gc/alloc { $size $entriesNeeded }
  
  $size.set # [: arena rootId
  
  # 
  # determine the space required for an allocation
  # 
  
  $size.get gc/-entry.size <=
  [ 
    # if the size is less than or equal to the data lump size, we don't need any entries
    # 
    1 
  ]
  [
    # otherwise, we will need 1 + enough to cover the size of the object being stored
    # 
    1                                    # the object entry itself
    $size.get gc/-entry.size / +         # how many full entries will the size need?
    $size.get gc/-entry.size % not not + # 1 if we have a partial page, else 0
  ]
  if
  
  # [: arena rootId
  
  # 
  # determine if there is sufficient space in the arena for the allocation
  # 
  
  # 
  # if there is not, collect the arena in an attempt to free up sufficient space
  # 
  
  # 
  # allocate the value
  # 
  
  # 
  # write the value into the appropriate root
  # 
  
  # 
  # return a gcref for the given root
  # 
  
  
;
