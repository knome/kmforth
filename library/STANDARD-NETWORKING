
# an actual bigendian system will require us to fire at an offset into the qword to hit the right spot
# probably move this into a system module and make it architecture dependent when we can
# maybe all this should be in memory/ instead of network/
# 
% network/with-if-local-endianness-is-little ( @rc @st )
  @ @rc @st 1 ;
;

% network/-foreach-endian-size (@entry.each)
  @ network/with-if-local-endianness-is-little network/-for-endian-size @entry ;
;

% network/-for-endian-size ((@sigil @mnemonic) @localIsLittle)
  :network/local-to-network-@mnemonic
    @(
      (@localIsLittle)
      (@little.expandIf)
      ` bswap @mnemonic@ [r14-8] `
    )
    @(
      (@localIsLittle)
      (@big.expandIfNot)
      # this space intentionally left blank
    )
  ;
  
  :network/network-to-local-@mnemonic
    @(
      (@localIsLittle)
      (@little.expandIf)
      ` bswap @mnemonic@ [r14-8] `
    )
    @(
      (@localIsLittle)
      (@big.expandIfNot)
      # this space intentionally left blank
    )
  ;
  
  :network/little-to-bigendian-@mnemonic
      ` bswap @mnemonic@ [r14-8] `
  ;
  
  :network/big-to-littleendian-@mnemonic
      ` bswap @mnemonic@ [r14-8] `
  ;
;

@ network/-foreach-endian-size (
    (q qword)
    (d dword)
    (w word)
    # no point in swapping a byte
);
