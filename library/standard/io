
# 
# simple commands interface
# 

# later we can check if the value
# is greater than 4096 or something
# and figure it's a string pointer
# if so, and otherwise assume it
# is an errno and do an appropriate
# lookup.
# 
# we might be able to introduce
# another magic local function that
# allows you to get the location of
# the calling frame, causing it to
# be passed in all secret like.
# 
# { $hello }
# 
# $hello.caller # causes a value to be pushed to stack and popped into a hidden local
#               # that will then be mov'd into the given local on command. complicates
#               # the caller a bit, and adds a bunch of little strings indicating
#               # where an error occurred, but it would be pretty useful
# 
# we could add a fn.needs_caller() to the function object to keep track of this
# 
# [: err message
# 
:or-die { $err }
  swap                   # [: message err
  dup $err.set           # [: message err
  not dup                # [: message (!err) (!err)
  [ swap pop ] $.callIf  # [: message (!err) | (!err) {called}
  $.leaveIf              # [: message | {leaves with empty stack on no error}
  
  # THERE IS AN ERROR, WE DIE HERE
  
  "FATAL-ERROR" log      # [: message
  log                    # [: 
  $err.get               # [: err
  
  # guess that any value under 1024 is an errno
  # any value over that is assumed to be a pointer to a string
  # 
  dup 1024 <             # [: err isErrno=(err<1024)
  dup                    # [: err isErrno isErrno
  
  # print the error if it is an errno
  # 
  [ { $isErrno }
    #                  # [: err isErrno
    $isErrno.set       # [: err 
    dup errno/strerror # [: err string
    log                # [: err
    $isErrno.get       # [: err isErrno
  ]                      # [: err isErrno isErrno onIsErrno
  $.callIf               # [: err isErrno {called or skipped}
  
  # print the error if it is a string
  # 
  not                    # [: err (!isErrno)
  [ dup log ]            # [: err (!isErrno) onNotErrno
  $.callIf               # [: err | err {we dup to keep the stack the same either way}
  
  pop # we could not dup and let the stack be inconsistent when we panic, but no
  
  "" panic
;

# [: filename
# [: fd err
# 
:create-new-file
  syscall/open/opt/readwrite syscall/open/opt/create or
  syscall/open/opt/exclusive or
  syscall/open/mode/standard-file
  syscall/open
;

# [: filename
# [: fd err
# 
:create-new-private-file
  syscall/open/opt/readwrite syscall/open/opt/create or
  syscall/open/opt/exclusive or
  syscall/open/mode/owner/readwrite
  syscall/open
;

# [: filename
# [: fd err
# 
:open-existing-file
  syscall/open/opt/readwrite
  syscall/open/mode/standard-file
  syscall/open
;

# [: fd
# [: err
# 
:close
  syscall/close
  swap pop
;

# [: "string"
# [: err
# 
:write
  syscall/STDOUT -write-all
;

# print a string or die on failure
# 
# [: "string"
# [: -
# 
:print "\n" 2 write-strings [ "PRINTERROR" log 1 exit ] $.callIf ;

# print a number or die on failure
# 
# [: number
# [: -
# 
:printno
  [
                              # [: value buffer=(number-buffer (tmp, on callstack))
    strings/unsigned-to-ascii # [: <string-pointer>
    print                     # [:
  ] strings/number-buffer.size stack/call-with-stack-buffer
;

# [: "string" fd
# [: err
# 
:-write-all { $fd $len $string  $thus $retry }
  $fd.set
  dup strings/length       # [: string string-length
  $len.set                 # [: string
  $string.set              # [:
  0 $thus.set              # [:
  
  $retry.here              # [:
  
  $string.get              # [: string
  $len.get $thus.get -     # [: string remaining
  $fd.get                  # [: string remaining fd
  syscall/write            # [: amount err
  
  dup                      # [: amount err err
  [                        # [: amount err err [on-err]
    swap     # [: err amount
    pop      # [: err
    dup      # [: err err (so we return 'err' on $.leaveIf)
  ]
  $.callIf                 # [: amount err=0 | err err
  $.leaveIf                # [: amount | err (leave)
  
  $thus.get +              # [: (amount+thus)
  dup $thus.set            # [: (amount+thus)
  
  $len.get swap -          # [: (len-(amount+thus))
  $retry.jumpIf            # [: (len-(amount+thus)) retry-addr
  
  0                        # [: 0
;

# panics on log write error
# 
# [: "string"
# [:
# 
:log
       syscall/STDERR -write-all [ 203 syscall/exit ] $.callIf
  "\n" syscall/STDERR -write-all [ 204 syscall/exit ] $.callIf
;

# does not return
# 
# [: "string"
# n/a
# 
:panic 
  log
  syscall/STDERR syscall/exit
;

# does not return
# 
# [: exitcode
# n/a
# 
:exit
  syscall/SYSCALL-EXIT syscall/one
  "implementation error - exit failed?" log
  [] loop
;

# output ordering is FIFO, not stack-backwards
# [: "hello" ", " "there" 3 write-strings --> "hello, there"
# 
#[: string... numstrings
#[: err
#
:write-strings
  {
    $n
  }

  # if there are no strings, don't bother
  # 
  dup 0 ==                     #[: n=0 1 | ss=strings... n=1+ 0
  $.leaveIf                    #[: <> 0 | ss... n
  
  $n.copy                      #[: ss... n
  
  # determine the size of the
  # stack-buffer we need for
  # the iovec array
  # 
  syscall/iovec.size *         #[: ss... <iovec-array-size>
  
  [
    { $escape }
    
    $escape.set
    
    [
      {
        $iovecs
        $total
      }
      
      #                          ##[: ss... <buffer>
      $iovecs.set                ##[: ss...
      0 $total.set               ##[: ss...
      
      # write the strings on the stack
      # into our iovec array from back
      # to front
      #
      $n.get                     ##[: ss... n
      [
        { $iovec }
        #                        ###[: ss... <index>
        $n.get swap - decr       ###[: ss... <reversed-index>
        syscall/iovec.size *     ###[: ss... <nth-iovec-offset>
        $iovecs.get +            ###[: ss... <nth-iovec>
        $iovec.set               ###[: ss... 
        dup                      ###[: ss... <s> <s>
        strings/length           ###[: ss... <s> <s-len>
        dup [+] $total.update    ###[: ss... <s> <s-len>
        $iovec.get               ###[: ss... <s> <s-len> <nth-iovec>
        syscall/iovec//len.set   ###[: ss... <s>
        $iovec.get               ###[: ss... <s> <iovec>
        syscall/iovec//base.set  ###[: ss...
      ]                          ##[: ss... n <todo>
      for-range                  ##[: 
      
      # loop
      #   write it
      #     on error fix up the stack and escape
      #     on remaining fix up the iovecs and continue
      #     on complete fix up the stack and escape
      #
      [
        syscall/STDOUT                          ###[: fd
        $iovecs.get                             ###[: fd iovecs
        $n.get                                  ###[: fd iovecs num-iovecs
        syscall/writev                          ###[: written err
        
        dup 0 !=                                ###[: written err <err!=0>
        [                                       
          "we need to update the iovecs" panic  ####[: written err
          swap pop $escape.get call             ####[: <> err
        ]
        when                                    ###[: written <err=0>
        
        # update the total remaining
        # and keep a copy of it
        #
        pop                                     ###[: written
        dup [swap - dup] $total.update          ###[: written <total-remaining>
        
        # if there is 0 total remaining
        # don't bother updating the iovecs
        # just leave
        # 
        0 ==                                    ###[: written <tr==0>
        [
           pop 0 $escape.get call               ####[: <> 0
        ]
        when                                    ###[: written
        
        # while written > next iovec
        # sub its value from written and remove it
        # 
        [ dup $iovecs.get syscall/iovec//len.get < ]
        [
          #                                     ####[: written
          $iovecs.get syscall/iovec//len.get -  ####[: written=<written - amount in current iovec len>
          [syscall/iovec.size +] $iovecs.update ####[: written  # (we move iovec ahead one entry
          [1 -] $n.update                       ####[: written  # (we decrease the count of iovecs by one
        ]
        while
        
        # if there is any written remaining,
        # sub it from the next iovec before looping
        #
        dup 0 >
        [
          [-] $iovecs.get syscall/iovec//len.update ####[: (empty) # we consume the rest of written updating current iovec/len
        ]
        when
      ]
      loop
    ]                            #[: ss... <iovec-array-size> <todo-with-stack-iovec>
    swap                         #[: ss... <todo-with-stack-iovec> <iovec-array-size>
    stack/call-with-stack-buffer #[: err <>
  ] stack/with-escape
  
;
