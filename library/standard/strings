
# a buffer specifically large enough to convert a number into a string
# 
% strings/number-buffer (@rc @st)
  @ @rc @st (
    (bytes type/u8 24) # we only need 21 (including newline), but this makes it align nicely with the 8byte per entry stack
  );
;
@ struct/define strings/number-buffer ;

# [: value number-buffer
# [: <pointer-to-start-of-string-in-buffer>
:strings/unsigned-to-ascii { $buffer $offset $loop }
  $buffer.set                                 # [: value
  
  strings/number-buffer//bytes.last-index     # [: value <last-index>
  $offset.set                                 # [: value
  
  # write a nul into the last byte of the number buffer
  # 
  strings/ascii-nul $offset.get $buffer.get   # [: value nul offset buffer
  strings/number-buffer//bytes.nth.set        # [: value
  
  # back up one step to start writing ascii numbers
  $offset.decr                                # [: value
  
  # while there is value left, write a character and back up a step
  [
    dup 10 % strings/ascii-zero +             #[: value <ascii-digit>
    $offset.get $buffer.get                   #[: value <ascii-digit> offset buffer
    strings/number-buffer//bytes.nth.set      #[: value
    10 /                                      #[: (value/10)
    $offset.decr                              #[: (value/10) # step back a step
  ]
  [ dup 0 is-bigger-than ]
  until
  
  pop
  
  $offset.incr
  $offset.get $buffer.get
  strings/number-buffer//bytes.nth.addr
;

#[: value todo -> (value-as-string todo)
#
:strings/with-unsigned-as-string
  { $todo }
  
  $todo.set
  
  strings/number-buffer.size
  [
    { $buffer } $buffer.copy
    strings/unsigned-to-ascii $todo.call
  ]
  stack/with-stack-buffer
;

:strings/length
  `
  sub r14, 8             ; pop the pointer to the string
  mov rax, [r14]         ; 
  mov rbx, 0             ; we'll track the length here
  
 .next:
  mov ch, byte [rax+rbx] ; grab the next character in the string
  test ch, ch            ; see if it is 0
  jz .done               ; if its nul, we're at the end, jump
  inc rbx                ; otherwise bump our counter
  jmp .next              ; and loop
 .done:
  mov [r14], rbx         ; push the string length onto the stack
  add r14, 8             ; 
  `
;

% strings/-define-ascii (@bit.each)
  @ strings/-define-ascii-bit @bit ;
;

% strings/-define-ascii-bit ((@name @value))
  :strings/ascii-@name @value ;
;

@ strings/-define-ascii (
  (nul     0)
  (bel     7)
  (lf     10) (line-feed 10) (nl 10) (newline 10)
  (cr     13) (carriage-return 13)
  (esc    27) (escape 27)
  (dot    46) (period 46) (. 46)
  (A      64)
  (Z      90)
  (zero   48)
  (one    49)
  (two    50)
  (three  51)
  (four   52)
  (five   53)
  (six    54)
  (seven  55)
  (eight  56)
  (nine   57)
  (a      97)
  (z     122)
);
