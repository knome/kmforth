#!/usr/bin/env python3

# everything is a lot easier if I give my callstack a little bit of state

# how to set gdb to step through assembly
# https://stackoverflow.com/questions/2420813/using-gdb-to-single-step-assembly-code-outside-specified-executable-causes-error

import sys
import os
import optparse
import contextlib
import re
import binascii

IMPLEMENTATION = 'kmforth/python'

G_SHOW_EXPANSIONS = False
G_EXPANSION_ID = [0]
G_SHOW_OPTIMIZATIONS = False
G_DEBUG_OPTIMIZATIONS = False
G_INLINE_THRESHOLD = 10
G_INLINE_ONLY = None
G_INLINE_EXCEPT = None

NUMBERS  = set( '0123456789' )
LETTERS  = set( 'abcdefghijklmnopqrstuvzwxyz' )

WORDSTART = LETTERS.union( set('_+-/*<>-%=.@!') )
WORDBITS  = WORDSTART.union( NUMBERS )

STRUCTBITS = ':;[]{}()'

def debug( *args, **kwargs ):
    if G_DEBUG_OPTIMIZATIONS:
        kwargs['file'] = sys.stderr
        print( *args, **kwargs )

def log( *args, **kwargs ):
    kwargs[ 'file' ] = sys.stderr
    print( *args, **kwargs )

def main():
    parser = optparse.OptionParser()
    parser.add_option(
        '--library-path'    ,
        dest='libraryPath'  ,
        default='./library' ,
    )
    parser.add_option(
        '--show-expansions'   ,
        action='store_true'   ,
        dest='showExpansions' ,
        default=False         ,
    )
    parser.add_option(
        '--optimize'        ,
        action='store_true' ,
        dest='optimize'     ,
        default=False       ,
    )
    parser.add_option(
        '--show-optimizations'   ,
        action='store_true'      ,
        dest='showOptimizations' ,
        default=False            ,
    )
    parser.add_option(
        '--debug-optimizations',
        action='store_true',
        dest='debugOptimizations',
        default=False,
    )
    parser.add_option(
        '--inline-only',
        dest='inlineOnly',
    )
    parser.add_option(
        '--inline-except',
        dest='inlineExcept',
    )
    parser.add_option(
        '--startname'     ,
        dest='startname'  ,
        default=':_start' ,
    )
    # not guaranteed to be the same on your box!
    parser.add_option(
        '--trampoline-size',
        dest='trampolineSize',
        default='32',
    )
    parser.add_option(
        '--trampoline-end-offset',
        dest='trampolineEndOffset',
        default='8',
    )
    options, free = parser.parse_args()
    if len( free ) != 1:
        raise Exception( 'usage: kmforth <path/to/file/to/compile>' )
    
    if free[0] == "":
        raise Exception( 'empty target path' )
    elif free[0] == "-":
        free[0] = "/dev/stdin"
    
    if options.startname == "":
        raise Exception( 'must specify startname' )
    
    startname = mangle( options.startname )
    
    if options.showExpansions:
        global G_SHOW_EXPANSIONS
        G_SHOW_EXPANSIONS = True
    
    if options.showOptimizations:
        global G_SHOW_OPTIMIZATIONS
        G_SHOW_OPTIMIZATIONS = True
        
    if options.debugOptimizations:
        global G_DEBUG_OPTIMIZATIONS
        G_DEBUG_OPTIMIZATIONS = True
        
    if options.inlineOnly:
        global G_INLINE_ONLY
        pattern = '.*(' + options.inlineOnly + ').*'
        if G_SHOW_OPTIMIZATIONS:
            log('[options] --inline-only pattern is %s' % repr( pattern ))
        G_INLINE_ONLY = re.compile( pattern )
    
    if options.inlineExcept:
        global G_INLINE_EXCEPT
        pattern = '.*(' + options.inlineExcept + ').*'
        if G_SHOW_OPTIMIZATIONS:
            log('[options] --inline-except pattern is %s' % repr( pattern ))
        G_INLINE_EXCEPT = re.compile( pattern )
    
    target = os.path.normpath( os.path.join( os.getcwd(), free[0] ) )
    
    seen    = set()
    pending = [ FileSource(
        origin      = '(main compilation target)' ,
        cwd         = os.getcwd()                 ,
        path        = target                      ,
        libraryPath = options.libraryPath         ,
    )]
    
    allNames  = set()
    allFns    = {}
    
    macroContext = MacroContext()
    
    namedMacroExpansions = []
    
    uniques = Uniques()
    
    while pending:
        
        pp = pending.pop()
        
        with print_on_exception( "WHILE PROCESSING FILE: %s" % repr( pp.path() ) ):
            
            incode = pp.read_source()
            
            characters = Source( parse_characters(
                data       = incode ,
                fileSource = pp     ,
            ))
            
            tokens = Source( parse_tokens(
                characters = characters
            ))
            
            definitions = Source( parse_definitions(
                tokens        = tokens       ,
                currentModule = pp           ,
                macroContext  = macroContext ,
                uniques       = uniques      ,
            ))
            
            while True:
                definition = definitions.take()
                if not definition:
                    break
                
                elif definition.definition_type() == 'function':
                    # functions have to be recursively
                    # added because they have lambdas
                    # in them
                    
                    fns = [ definition ]
                    while fns:
                        fn = fns.pop(0)
                        if fn.name().value() in allNames:
                            raise Exception( 'duplicate function/macro name: %s' % repr( definition.name() ) )
                        else:
                            allNames.add( fn.name().value() )
                            allFns[ fn.name().value() ] = fn
                            
                            for subfn in fn.body().subfns():
                                fns.append( subfn )
                
                elif definition.definition_type() == 'include':
                    # includes can be specified all over
                    # we just discard all repeat references
                    
                    norm = os.path.normpath( definition.path() )
                    if norm not in seen:
                        pending.append( definition )
                        seen.add( norm )
                    
                elif definition.definition_type() == 'macro-definition':
                    
                    if definition.name().value() in allNames:
                        raise Exception( 'duplicate function/macro name: %s' % repr( definition.name() ) )
                    else:
                        allNames.add( definition.name().value() )
                        macroContext.add_macro( definition.name().value(), definition )
                    
                elif definition.definition_type() == 'named-macro-expansion':
                    namedMacroExpansions.append( definition )
                    
                else:
                    raise Exception( 'unknown definition type: %s' % repr( definition ) )
    
    if namedMacroExpansions:
        macroFunctions = expand_macros(
            namedMacroExpansions = namedMacroExpansions ,
            macroContext         = macroContext         ,
            uniques              = uniques              ,
        )
        fns = []
        for mfn in macroFunctions:
            fns.append( mfn )
        while fns:
            fn = fns.pop(0)
            if fn.name().value() in allFns:
                raise Exception(
                    'macro-generated function-name already defined: %s' % repr( fn.name().value() )
                )
            else:
                allNames.add( fn.name().value() )
                allFns[ fn.name().value() ] = fn
                for subfn in fn.body().subfns():
                    fns.append( subfn )
    
    callgraph, usedFns = analyze_functions( allFns, startname = startname )
    
    if options.optimize:
        outFns = optimize( allFns, usedFns, callgraph, startname )
        # drop functions we optimized out
        callgraph, usedFns = analyze_functions( outFns, startname = startname )
    else:
        outFns = allFns
    
    outcode = generate_code(
        functions           = outFns                           ,
        usedFunctions       = usedFns                          ,
        startname           = startname                        ,
        trampolineSize      = int(options.trampolineSize)      ,
        trampolineEndOffset = int(options.trampolineEndOffset) ,
    )
    
    print( outcode )

@contextlib.contextmanager
def print_on_exception( comment ):
    try:
        yield
    except Exception:
        log( comment )
        raise

class FileSource:
    
    NN = 0
    
    def __init__(
        self        ,
        origin      ,
        cwd         ,
        path        ,
        libraryPath ,
    ):
        self._fileno = self.NN
        self.NN += 1
        
        self._origin      = origin
        self._cwd         = cwd
        self._path        = path
        self._libraryPath = libraryPath
        return
    
    def fileno( self ):
        return self._fileno
    
    def definition_type( self ):
        return 'include'
    
    def path(
        self ,
    ):
        if (
            self._path.startswith('/')
            or
            self._path.startswith('./')
            or
            self._path.startswith('../')
        ):
            initial = os.path.join(
                self._cwd  ,
                self._path ,
            )
        else:
            initial = os.path.join(
                self._libraryPath ,
                self._path        ,
            )
        
        if os.path.isdir( initial ):
            full = initial + '/default'
            if os.path.isdir( full ):
                raise Exception( 'default in a directory import cannot itself be a directory: %s' % repr( full ) )
        else:
            full = initial
        
        return full
    
    def cwd_for_includes(
        self, 
    ):
        return os.path.dirname( self.path() )
    
    def library_path(
        self ,
    ):
        return self._libraryPath
    
    def read_source(
        self ,
    ):
        try:
            with open( self.path() ) as ff:
                data = ff.read()
                return data
        except Exception as ee:
            raise Exception( 'error reading path=%s %s: %s, %s' % (
                repr( self._path )  ,
                str( self._origin ) ,
                str( type( ee ) )   ,
                str( ee )           ,
            ))

class Source:
    def __init__(
        self   ,
        source ,
    ):
        self._iterator = iter( source )
        self._pending  = None
        self._done     = False
    
    def peek(
        self ,
    ):
        if self._done:
            return None
        elif self._pending == None:
            self._pending = next( self._iterator, None )
            if self._pending == None:
                self._done = True
        
        return self._pending
    
    def take(
        self ,
    ):
        vv = self.peek()
        self._pending = None
        return vv

class Location:
    def __init__(
        self     ,
        fileno   ,
        filename ,
        line     ,
        column   ,
    ):
        self._fileno   = fileno
        self._filename = filename
        self._line     = line
        self._column   = column

    def __repr__(
        self
    ):
        return '(%s:%s:%s)' % (
            self._filename ,
            self._line     ,
            self._column   ,
        )
    
    def fileno   ( self ): return self._fileno
    def filename ( self ): return self._filename
    def line     ( self ): return self._line
    def column   ( self ): return self._column

class Character:
    def __init__(
        self      ,
        location  ,
        character ,
    ):
        self._location  = location
        self._character = character
        return
    
    def __repr__(
        self ,
    ):
        return '<Character character=%s>' % repr( self._character )
    
    def location  ( self ): return self._location
    def character ( self ): return self._character

class Token:
    def __init__(
        self     ,
        location ,
        kind     ,
        value    ,
    ):
        self._location = location
        self._kind     = kind
        self._value    = value
        return
    
    def location ( self ): return self._location
    def kind     ( self ): return self._kind
    def value    ( self ): return self._value
    
    def __repr__( self ):
        return '<Token %s kind=%s value=%s>' % (
            repr( self._location ),
            repr( self._kind     ),
            repr( self._value    ),
        )
    
    def simple( self ):
        if self.kind() == 'string':
            return repr( self._value )
        elif self.kind() == 'code':
            return '`' + repr( self._value )[1:-1] + '`'
        elif self._value == None:
            return self._kind
        else:
            return str(self._value)

def parse_characters( data, fileSource ):
    assert isinstance( data, str )
    
    line   = 1
    column = 0
    
    for cc in data:
        yield Character(
            location = Location(
                fileno   = fileSource.fileno() ,
                filename = fileSource.path()   ,
                line     = line                ,
                column   = column              ,
            ),
            character = cc ,
        )
        
        if cc == "\n":
            line += 1
            column = 0
        else:
            column += 1

def parse_tokens( characters ):
    
    while True:
        nc = characters.take()
        if not nc:
            break
        cc = nc.character()
        
        if cc == '#':
            discard_comment( characters = characters )
        
        elif cc in ' \n\t':
            discard_whitespace( characters = characters )
        
        elif cc == '"':
            yield extract_string( initial = nc, characters = characters )
            
        elif cc == "`":
            yield extract_code( initial = nc, characters = characters )
        
        elif cc == '-' or cc in NUMBERS:
            yield extract_number( initial = nc, characters = characters )
        
        elif cc.lower() in WORDSTART or cc == '$' or cc == '&':
            yield extract_word( initial = nc, characters = characters )
            
        elif cc.lower() in STRUCTBITS:
            yield Token(
                location = nc.location() ,
                kind     = cc.lower()    ,
                value    = None          ,
            )
        
        else:
            raise Exception( 'unknown character: %s' % repr( cc ) )

def discard_comment( characters ):
    while True:
        pc = characters.take()
        if not pc:
            break
        elif pc.character() == '\n':
            break
    return

def discard_whitespace( characters ):
    while True:
        pc = characters.peek()
        if not pc:
            break
        elif pc.character() in ' \t\n':
            characters.take()
        else:
            break
    return

def extract_string( initial, characters ):
    bits   = []
    escape = False
    while True:
        nc = characters.take()
        if not nc:
            raise Exception( 'unterminated string starting at: %s' % repr( initial ) )
        cc = nc.character()
        
        if escape:
            escape = False
            if cc == 'n':
                bits.append( '\n' )
                continue
            elif cc == '"':
                bits.append( '"' )
                continue
            elif cc == 't':
                bits.append( '\t' )
                continue
            else:
                raise Exception( 'unknown escape: %s' % repr( '\\' + cc ) )
        else:
            if cc == '"':
                break
            elif cc == "\\":
                escape = True
                continue
            else:
                bits.append( cc )
                continue
    
    value = ''.join( bits )
    
    kind = 'string'
    if '@' in value:
        kind = 'macrostring'
    
    return Token(
        location = initial.location() ,
        kind     = kind               ,
        value    = value              ,
    )

def extract_number( initial, characters ):
    
    if initial.character() == '-' and ( ( not characters.peek() ) or ( characters.peek().character() not in NUMBERS ) ):
        return extract_word( initial, characters )
    
    bits = [ initial.character() ]
    while True:
        pc = characters.peek()
        if not pc:
            break
        cc = pc.character()
        if cc.lower() in '0123456789.xoabcdef':
            bits.append( cc )
            characters.take()
            continue
        else:
            break
    
    value = ''.join( bits )
    given = value
    
    try:
        negative = False
        if value.startswith('-'):
            value    = value[1:]
            negative = True
        
        if '-' in value:
            raise Exception( '"-" in number other than at start: %s' % repr( given ) )
        
        if '.' in value:
            raise Exception( 'float not currently handled' )
        
        base = 10
        if value.startswith( '0x' ):
            base = 16
            value = value[2:]
        elif value.startswith( '0o' ):
            base = 8
            value = value[2:]
        elif value.startswith( '0b' ):
            base = 2
            value = value[2:]
        
        # should throw if any trash is left in the number
        value = int( value, base )
        
        if negative:
            value = -value
        
    except ValueError as err:
        raise Exception( 'error parsing number: %s' % repr( given ) )
    
    tt = Token(
        location = initial.location() ,
        kind     = 'integer'          ,
        value    = value              ,
    )
    
    return tt

def extract_code( initial, characters ):
    bits = []
    while True:
        pc = characters.take()
        if not pc:
            raise Exception( 'unterminated code segment starting at: %s' % repr( initial ) )
        cc = pc.character()
        if cc == '`':
            break
        else:
            bits.append( cc )
        
    value = ''.join(bits)
    if '@' in bits:
        kind = 'macrocode'
    else:
        kind = 'code'
    
    return Token(
        location = initial.location() ,
        kind     = kind               ,
        value    = value              ,
    )

def extract_word( initial, characters ):
    bits = [ initial.character() ]
    while True:
        pc = characters.peek()
        if not pc:
            break
        cc = pc.character()
        if cc.lower() in WORDBITS or cc == '$':
            characters.take()
            bits.append( cc )
        else:
            break
    
    if initial.character() == '$':
        kind  = 'localfn'
        value = ''.join(bits)
    elif initial.character() == '&':
        kind  = 'fnref'
        value = ''.join(bits)[1:]
    elif initial.character() == '@' or '@' in bits:
        if len( bits ) == 1:
            kind  = '@'
            value = None
        else:
            kind  = 'macrovar'
            value = ''.join(bits)
    else:
        kind  = 'word'
        value = ''.join(bits)
    
    token = Token(
        location = initial.location() ,
        kind     = kind               ,
        value    = value              ,
    )
    
    if value and '$' in value[1:]:
        raise Exception(
            '"$" cannot be used inside a word, just at the start of a local, found: %s' % repr( token )
        )
    
    return token

def extract_macrovar( initial, characters ):
    bits = []
    while True:
        pc = characters.peek()
        if not pc:
            break
        elif pc.character().lower() not in WORDBITS:
            break
        
        characters.take()
        bits.append( pc.character() )
    
    value = ''.join( bits )
    
    if value == '':
        return Token(
            location = initial.location() ,
            kind     = '@'                ,
            value    = None               ,
        )
    else:
        return Token(
            location = initial.location() ,
            kind     = 'macrovar'         ,
            value    = value              ,
        )

def parse_definitions(
    tokens        ,
    currentModule ,
    macroContext  ,
    uniques       ,
):
    while True:
        initial = tokens.take()
        if not initial:
            return
        elif initial.kind() == ':':
            yield parse_named_function(
                initial       = initial       ,
                tokens        = tokens        ,
                currentModule = currentModule ,
                macroContext  = macroContext  ,
                uniques       = uniques       ,
            )
        elif initial.kind() == '@':
            pp = tokens.peek()
            if pp and pp.kind() == 'string':
                yield parse_include(
                    initial       = initial       ,
                    tokens        = tokens        ,
                    currentModule = currentModule ,
                )
            else:
                yield parse_named_macro_expansion(
                    initial       = initial       ,
                    tokens        = tokens        ,
                    currentModule = currentModule ,
                    macroContext  = macroContext  ,
                    uniques       = uniques       ,
                )
        elif initial.kind() == 'word' and initial.value() == '%':
            yield parse_macro_definition(
                initial       = initial       ,
                tokens        = tokens        ,
                currentModule = currentModule ,
            )
        else:
            raise Exception(
                'unknown definition marker: %s' % repr( initial )
            )

def parse_named_function(
    initial       ,
    tokens        ,
    currentModule ,
    macroContext  ,
    uniques       ,
):
    name = tokens.take()
    if not name:
        raise Exception(
            'expected name of definition after %s, found end of data' % repr( initial )
        )
    if name.kind() == 'word':
        pass
    else:
        raise Exception(
            'expected name of definition after %s, found: %s' % (
                repr( initial ) ,
                repr( name )    ,
            )
        )
    
    with print_on_exception( "WHILE PROCESSING FUNCTION: %s" % repr( name ) ):
        bodyBits = capture_balanced_bits_til_terminator( tokens )
        
        end = tokens.take()
        if end == None:
            raise Exception( 'expected ";" after %s' % repr( initial ) )
        elif end.kind() != ';':
            raise Exception(
                'expected ";" after %s, found %s' % ( repr( initial ), repr( end ) )
            )
        
        bodyBits.append( end )
        
        body = parse_body(
            initial = initial,
            tokens  = Source( expand_bitstream(
                macroContext = macroContext       ,
                tokens       = Source( bodyBits ) ,
                uniques      = uniques            ,
            )),
            parent  = mangle(':' + name.value()),
            uniques = uniques,
        )
    
    return NamedFunction(
        location = initial.location() ,
        name     = name               ,
        body     = body               ,
    )

def parse_lambda_definition( initial, tokens, parent, uniques ):
    name = 'kmlambda_%s' % str(uniques.get())
    body = parse_body(
        initial ,
        tokens  ,
        name    ,
        uniques ,
    )
    return LambdaFunction(
        location   = initial.location() ,
        lambdaName = name               ,
        body       = body               ,
        parent     = parent             ,
    )

def parse_body(
    initial ,
    tokens  ,
    parent  ,
    uniques ,
):
    localvars = parse_optional_locals( tokens )
    
    commands = []
    subfns   = []
    while True:
        pt = tokens.peek()
        if not pt:
            break
        elif pt.kind() == ';':
            break
        elif pt.kind() == ']':
            break
        elif pt.kind() == '[':
            tokens.take()
            subfntoks = []
            depth = []
            while True:
                st = tokens.take()
                if st == None:
                    if len(depth):
                        raise Exception( 'unclosed %s at %s' % (repr(depth[-1].kind()), depth[-1].location()) )
                    else:
                        raise Exception( 'unclosed %s at %s' % (repr(pt.kind()), pt.location()))
                elif st.kind() in ']}':
                    if st.kind() == ']' and len(depth) == 0:
                        break
                    elif depth[-1].kind() == '[':
                        depth.pop()
                        subfntoks.append( st )
                    elif depth[-1].kind() == '{':
                        depth.pop()
                        subfntoks.append( st )
                    else:
                        raise Exception( 'unexpected "]" does not line up with a matching "[" at %s' % pt.location() )
                elif st.kind() == '[':
                    depth.append(st)
                    subfntoks.append( st )
                elif st.kind() == '{':
                    depth.append(st)
                    subfntoks.append( st )
                else:
                    subfntoks.append( st )
            subfn = parse_lambda_definition(
                initial = pt                  ,
                tokens  = Source( subfntoks ) ,
                parent  = parent              ,
                uniques = uniques             ,
            )
            subfns.append( subfn )
            commands.append( Token(
                location = subfn.location()     ,
                kind     = 'subfn'              ,
                value    = subfn.name().value() ,
            ))
        
        elif pt.kind() == 'word':
            tokens.take()
            commands.append( Token(
                location = pt.location()              ,
                kind     = 'word'                     ,
                value    = mangle( ':' + pt.value() ) ,
            ))
        elif pt.kind() == 'fnref':
            tokens.take()
            commands.append( Token(
                location = pt.location()              ,
                kind     = 'fnref'                    ,
                value    = mangle( ':' + pt.value() ) ,
            ))
        elif pt.kind() in [ 'localfn', 'string', 'integer', 'code' ]:
            tokens.take()
            commands.append( pt )
            
        elif pt.kind() == '(':
            raise Exception( 'macrolist outside of macro-parameters or arguments: %s' % repr( pt ) )
            
        else:
            raise Exception( 'what is %s' % repr( pt ) )
    
    return Body(
        location  = initial.location() ,
        commands  = commands           ,
        localvars = localvars          ,
        subfns    = subfns             ,
    )

def parse_optional_locals( tokens ):
    pt = tokens.peek()
    if not pt:
        return []
    elif pt.kind() != '{':
        return []
    else:
        tokens.take()
    
    seen       = set()
    localNames = []
    
    while True:
        pt = tokens.peek()
        if pt == None:
            break
        elif pt.kind() != 'localfn':
            break
        else:
            tokens.take()
            
            vv = pt.value()
            sz = 8
            if '.' in vv:
                fore, aft = vv.split('.',1)
                if not (fore[1:] and fore[1:].isdigit()):
                    raise Exception(
                        'localfn size designation must be a number ($<size>.<name>), found %s' % pt
                    )
                else:
                    vv = '$' + aft
                    sz = int(fore[1:], 10)
                    if sz < 1:
                        raise Exception( 'localfn size designation must be an integer of 1 or greater' )
                    if sz % 8 != 0:
                        sz += 8 - sz % 8
            
            if '.' in vv:
                raise Exception( 'localfn name cannot contain "." (must be $<size>.<name> or $<name>)' )
            
            if pt.value() in seen:
                raise Exception( 'duplicate localfn name declaration: %s' % repr( pt ) )
            else:
                seen.add( vv )
                localNames.append( (vv,sz) )
    
    ct = tokens.take()
    if not ct:
        raise Exception( 'expected } following: %s' % repr( pt ) )
    elif ct.kind() != '}':
        raise Exception( 'expected } following %s, found %s' % ( repr( pt ), repr( ct ) ) )
    
    return localNames

def mangle( name ):
    bits = []
    
    for cc in name:
        if cc.lower() in LETTERS:
            bits.append( cc )
        elif cc in NUMBERS:
            bits.append( cc )
        else:
            for byte in cc.encode( 'utf-8' ):
                bits.append( '_' + hex(byte)[2:] + '_' )
    
    final = 'kmfn_' + ''.join( bits )
    
    return final

def unmangle( name ):
    bits = []
    ss   = Source( name[len('kmfb_'):] )
    
    if name.startswith( 'kmlambda'):
        # lambdas aren't mangled and it is useful to
        # call this were lambdas and functions are combined
        return name
    
    while ss.peek() != None:
        vv = ss.take()
        if vv == '_':
            bits.append( ss.take() + ss.take() )
            ss.take()
        else:
            bits.append( ''.join( hex(cc)[2:] for cc in vv.encode( 'utf-8' ) ) )
    
    return binascii.a2b_hex( ''.join(bits) ).decode( 'utf-8' )

class NamedFunction:
    
    def rewriting_commands( self, new ):
        return NamedFunction(
            location = self._location                       ,
            name     = self._name                           ,
            body     = self._body.rewriting_commands( new ) ,
        )
    
    def rewriting_locals( self, new ):
        return NamedFunction(
            location = self._location                     ,
            name     = self._name                         ,
            body     = self._body.rewriting_locals( new ) ,
        )
    
    def __init__(
        self        ,
        location    ,
        name        ,
        body        ,
    ):
        self._location = location
        self._name     = name
        self._body     = body
        return
    
    def __repr__( self ):
        return '<NamedFunction name=%s commands=%s>' % (
            repr( self._name.value() ) ,
            repr( len( self._body.body_details(self._name.value()).commands() ) ) ,
        )
    
    def simple( self ):
        return ': %s %s ;' % (
            self._name.simple()                                       ,
            ' '.join( bit.simple() for bit in self._body.commands() ) ,
        )
    
    def definition_type( self ):
        return 'function'
    
    def location ( self ): return self._location
    def body     ( self ): return self._body.body_details(self._name.value())
    def parent   ( self ): return None
    
    def name( self ):
        return Token(
            location = self._name.location()            ,
            kind   = 'word'                             ,
            value  = mangle( ':' + self._name.value() ) ,
        )

class LambdaFunction:
    
    def rewriting_commands( self, new ):
        return LambdaFunction(
            location   = self._location                       ,
            lambdaName = self._lambdaName                     ,
            parent     = self._parent                         ,
            body       = self._body.rewriting_commands( new ) ,
        )
    
    def rewriting_locals( self, new ):
        return LambdaFunction(
            location   = self._location                     ,
            lambdaName = self._lambdaName                   ,
            parent     = self._parent                       ,
            body       = self._body.rewriting_locals( new ) ,
        )
    
    def __init__(
        self       ,
        location   ,
        lambdaName ,
        body       ,
        parent     ,
    ):
        self._location   = location
        self._lambdaName = lambdaName
        self._body       = body
        self._parent     = parent
        return
    
    def __repr__( self ):
        return '<LambdaFunction %s name=%s commands=%d>' % (
            repr( self._location )       ,
            self.name()                  ,
            len( self._body.body_details(self._lambdaName).commands() ) ,
        )
    
    def kind( self ): return 'lambda'
    
    def location ( self ): return self._location
    def body     ( self ): return self._body.body_details(self._lambdaName)
    def parent   ( self ): return self._parent
        
    def is_closure( self, functions ):
        return self._body.body_details(self._lambdaName).is_closure( functions )
    
    def name( self ):
        return Token(
            location = self._location  ,
            kind   = 'word'            ,
            value  = self._lambdaName ,
        )

class Body:
    
    def rewriting_commands( self, new ):
        return Body(
            location  = self._location  ,
            commands  = new             ,
            localvars = self._localvars ,
            subfns    = self._subfns    ,
        )
    
    def rewriting_locals( self, new ):
        return Body(
            location  = self._location ,
            commands  = self._commands ,
            localvars = new            ,
            subfns    = self._subfns   ,
        )
    
    def __init__(
        self      ,
        location  ,
        commands  ,
        localvars ,
        subfns    ,
    ):
        self._location  = location
        self._commands  = commands
        self._localvars = localvars
        self._subfns    = subfns
        
    def body_details( self, name ):
        return BodyDetails(
            name      = name            ,
            location  = self._location  ,
            commands  = self._commands  ,
            localvars = self._localvars ,
            subfns    = self._subfns    ,
        )
        
class BodyDetails:
    
    def __init__(
        self      ,
        name      ,
        location  ,
        commands  ,
        localvars ,
        subfns    ,
    ):
        self._name      = name
        self._location  = location
        self._commands  = commands
        self._localvars = localvars
        self._subfns    = subfns
    
    def location( self ):
        return self._location
    
    def __repr__( self ):
        return '<Definition %s command.cnt=%s>' % (
            repr( self._location )        ,
            repr( len( self._commands ) ) ,
        )
    
    def is_closure( self, functions ):
        unresolvedNonLocals = list( self.unresolved_nonlocals( functions ) )
        return bool( len( unresolvedNonLocals ) )
    
    def has_local(self, name):
        return any(name == localname for localvar in self._localvars for (localname,localsize) in [localvar])
    
    def unresolved_nonlocals( self, functions ):
        for command in self._commands:
            if command.kind() == 'localfn':
                if not command.value().startswith('$.'):
                    name, _ = command.value().split('.',1)
                    if not self.has_local(name):
                        yield name
            
            if command.kind() == 'subfn':
                for unresolvedNonLocal in functions[ command.value() ].body().unresolved_nonlocals( functions ):
                    if not self.has_local(unresolvedNonLocal):
                        yield unresolvedNonLocal
    
    def localvars( self ):
        return self._localvars
    
    def subfns( self ):
        return self._subfns
    
    def commands( self ):
        return self._commands
    
    def frame_offsets(
        self                ,
        functions           ,
        trampolineSize      ,
        trampolineEndOffset ,
    ):
        return FrameOffsets(
            name                = self._name          ,
            location            = self._location      ,
            localvars           = self._localvars     ,
            commands            = self._commands      ,
            functions           = functions           ,
            trampolineSize      = trampolineSize      ,
            trampolineEndOffset = trampolineEndOffset ,
        )

class FrameOffsets:
    
    def __init__(
        self                ,
        name                ,
        location            ,
        localvars           ,
        commands            ,
        functions           ,
        trampolineSize      ,
        trampolineEndOffset ,
    ):
        self._location = location
        
        if trampolineSize % 8 != 0:
            raise Exception( 'trampoline-size should be align 8' )
        
        if trampolineEndOffset % 8 != 0:
            raise Exception( 'trampoline-end-offset should be align 8' )
        
        trampolineSizeSlots = trampolineSize // 8
        trampolineEndOffsetSlots = trampolineEndOffset // 8
        
        self._localvars      = localvars
        self._localvarNames  = []
        self._localvarSizes  = {}
        self._localvarSlotNo = {}
        
        self._nonlocalvarNames                     = []
        self._nonlocalvarTrampolineSlotNo          = {}
        self._nonlocalvarTargetSlotNo              = {}
        self._nonlocalvarNumSlotsUsedAfterNonLocal = None
        
        # slotno is hereby defined as negative slot index to start of data from r15 cursor (which sites 1 slot past data)
        # therefore, all slots must begin at 1 and go up
        # to get the slotno, add the size in slots of the item to the current slotno
        
        slotno = 0
        
        for (localname,size) in localvars:
            if size % 8 != 0:
                raise Exception( 'implementation error: localfn size not divisible by 8: %s' % repr( (name,size) ) )
            else:
                slotno += size // 8
                
                self._localvarNames.append(localname)
                self._localvarSizes[ localname ] = size
                self._localvarSlotNo[ localname ] = slotno
                
        for cc in commands:
            if cc.kind() == 'subfn':
                if functions[ cc.value() ].is_closure( functions ):
                    
                    # slotnos are negative into the frame from r15
                    # data still points forwards, however.
                    # so for something to found immediately after something else's data
                    # it needs to be pushed immediately before that something
                    
                    slotno += 1
                    
                    self._nonlocalvarTargetSlotNo[cc.value()] = slotno
                    
                    slotno += trampolineSizeSlots
                    
                    self._nonlocalvarNames.append( cc.value() )
                    self._nonlocalvarTrampolineSlotNo[ cc.value() ] = slotno
                    
        self._slotsUsed = slotno
        
        return
    
    def frame_slots_used( self ):
        return self._slotsUsed
    
    def frame_total_size( self ):
        return self._slotsUsed * 8
    
    def is_localvar( self, name ):
        return name in self._localvars
    
    def localvars( self ):
        return self._localvars
    
    def localvars_names( self ):
        return self._localvarNames
    
    def localvar_size( self, name ):
        if name not in self._localvarSizes:
            raise Exception( 'implementation error: used name not in localvars: %s' % repr( name ) )
        else:
            return self._localvarSizes[ name ]
    
    def localvar_slotno(
        self ,
        name ,
    ):
        return self._localvarSlotNo.get( name, None )
    
    def nonlocalvar_names( self ):
        return self._nonlocalvarNames
    
    def nonlocalvar_trampoline_slotno( self, name ):
        return self._nonlocalvarTrampolineSlotNo.get( name, None )
    
    def nonlocalvar_target_slotno( self, name ):
        return self._nonlocalvarTargetSlotNo.get( name, None )
    
    def nonlocalvar_slots_used_after( self, name ):
        return self._nonlocalvarNumSlotsUsedAfterNonLocal.get( name, None )

def parse_include( initial, tokens, currentModule ):
    path = tokens.take()
    if path == None:
        raise Exception( 'found nothing while expecting path after: %s' % repr( initial ) )
    
    if path.kind() != 'string':
        raise Exception( 'expected path after @, found %s' % repr( path ) )
    
    end = tokens.take()
    if end == None:
        raise Exception( 'found nothing while expecting ";" after: %s' % repr( path ) )
    
    if end.kind() != ';':
        raise Exception( 'expected ; after path, found %s' % repr( end ) )
    
    return FileSource(
        origin      = '(included from file=%s)' % currentModule.path() ,
        cwd         = currentModule.cwd_for_includes()                 ,
        path        = path.value()                                     ,
        libraryPath = currentModule.library_path()                     ,
    )

class MacroContext:
    def __init__(
        self                      ,
        inMacroDefinition = False ,
        _macros  = None           ,
        _macrovars = None           ,
    ):
        self._inMacroDefinition = inMacroDefinition
        self._macros            = _macros  or {}
        self._macrovars         = _macrovars or {}
        return
    
    def __repr__(
        self ,
    ):
        return '<MacroContext #macros=%s macrovars=%s>' % (
            len( self._macros )     ,
            repr( self._macrovars ) ,
        )
    
    def copy( self ):
        return MacroContext(
            inMacroDefinition = self._inMacroDefinition ,
            _macros           = self._macros.copy()     ,
            _macrovars        = self._macrovars.copy()  ,
        )
    
    def in_macro_definition( self ):
        return self._inMacroDefinition
    
    def set_in_macro_definition( self ):
        self._inMacroDefinition = True
    
    def has_macro( self, name ):
        return name in self._macros
    
    def add_macro( self, name, macro ):
        if name in self._macros:
            raise Exception( 'duplicate macro: %s' % repr( name ) )
        else:
            self._macros[ name ] = macro
    
    def get_macro( self, name ):
        if name not in self._macros:
            raise Exception( 'unknown macro: %s' % repr( name ) )
        else:
            return self._macros[ name ]
    
    def has_macrovar( self, name ):
        return name in self._macrovars
    
    def add_macrovar( self, name, value ):
        if name in self._macrovars:
            raise Exception( 'duplicate macro variable: %s' % repr( name ) )
        else:
            self._macrovars[ name ] = value
    
    def get_macrovar( self, name ):
        if name not in self._macrovars:
            raise Exception( 'unknown macro variable: %s' % repr( name ) )
        else:
            return self._macrovars[ name ]
    
    def expand_macrovar( self, name ):
        if re.match( '^[@][A-Za-z][A-Za-z0-9]*$', name.value() ):
            return self._as_is( name )
        else:
            return self._interpolate_word( name )
    
    def _as_is( self, name ):
        if self.has_macrovar( name.value() ):
            return self.get_macrovar( name.value() )
        else:
            raise Exception( 'unknown macrovar: %s' % repr( name ) )
        
    def _interpolate_word( self, name ):
        
        def replace_with_stringized( mm ):
            ss = mm.group('name')
            if not self.has_macrovar( ss ):
                raise Exception( 'unknown macrovar in interpolation of %s: %s' % ( repr( name ), repr( ss ) ) )
            vv = self.get_macrovar( ss )
            if vv.kind() == 'word':
                return vv.value()
            elif vv.kind() == 'integer':
                return str( vv.value() )
            elif isinstance( vv, MacroList ):
                raise Exception(
                    (
                        'you cannot expand a macrovar containing a macrolist that is touching anything else.' 
                        ' expansion rules are applied in parameters only.'
                        ' they interpolate in expansions.'
                        ' erroneous expansion: %s'
                    ) % repr( name )
                )
            else:
                raise Exception( 'some type I did not check for interpolation compatibility: %s' % repr( vv ) )
        
        interpolated = re.sub( '(?P<name>[@][A-Za-z][A-Za-z0-9]*)', replace_with_stringized, name.value() )
        
        if not interpolated:
            raise Exception( 'is this even possible?' )
        elif interpolated[0].lower() not in WORDSTART:
            raise Exception( 'interpolation of %s created illegal word %s starting with non-wordstart: %s' % (
                repr( name )            ,
                repr( interpolated )    ,
                repr( interpolated[0] ) ,
            ))
        else:
            for ii in interpolated[1:]:
                if ii.lower() not in WORDBITS:
                    raise Exception(
                        'interpolation of %s create illegal word %s containing non-wordbit: %s' % (
                            repr( name )         ,
                            repr( interpolated ) ,
                            repr( ii )           ,
                        )
                    )
        
        return Token(
            location = name.location() ,
            kind     = 'word'          ,
            value    = interpolated    ,
        )

def parse_macro_definition(
    initial       ,
    tokens        ,
    currentModule ,
):
    # % name ( parameters ) 
    #     : function definition
    #       we should not expand yet
    #       just collect the contents
    #     ;
    #     @ named/macro/expansion
    #       and vars we should also collect
    #       for later expansion when the
    #       containing macro is expanded
    #     ;
    #     ...repeat...
    # ;
    
    name = tokens.take()
    if not name:
        raise Exception( 'expected name after macro definition sigil: %s' % repr( initial ) )
    elif name.kind() != 'word':
        raise Exception( 'expected name after macro definition sigil to be word, found: %s' % repr( name ) )
    
    parameters = parse_macro_parameter_list(
        initial = initial ,
        tokens  = tokens  ,
    )
    
    unexpandedDefinitions = parse_unexpanded_definitions(
        tokens        = tokens        ,
        currentModule = currentModule ,
    )
    
    closer = tokens.take()
    if not closer:
        raise Exception( 'expected ";" to terminate macro definition starting at: %s' % repr( initial ) )
    elif closer.kind() != ';':
        raise Exception( 'expected ";" to terminate macro definition starting at %s, instead found: %s' % (
            repr( initial ) ,
            repr( closer  ) ,
        ))
    
    return MacroDefinition(
        name                  = name                  ,
        parameters            = parameters            ,
        unexpandedDefinitions = unexpandedDefinitions ,
    )

class MacroDefinition:
    def __init__(
        self                  ,
        name                  ,
        parameters            ,
        unexpandedDefinitions ,
    ):
        self._name                  = name
        self._parameters            = parameters
        self._unexpandedDefinitions = unexpandedDefinitions
        return
    
    def name( self ):
        return self._name
    
    def definition_type( self ):
        return 'macro-definition'
    
    def parameters( self ):
        return self._parameters
    
    def unexpanded_definitions( self ):
        return self._unexpandedDefinitions

def parse_macro_parameter_list(
    initial             , # macro initial character
    tokens              ,
):
    start = tokens.take()
    if not start:
        raise Exception( 'expected "(" to start macro parameters in macro starting at: %s' % repr( initial ) )
    elif start.kind() != '(':
        raise Exception( 'expected "(" to start macro parameters in macro starting at %s, instead found: %s' % (
            repr( initial ),
            repr( start   ),
        ))
    
    parameters = parse_macro_parameters(
        initial = initial ,
        tokens  = tokens  ,
    )
    
    closer = tokens.take()
    if not closer:
        raise Exception( 'expected ")" to close macro parameters in macro starting at: %s' % repr( initial ) )
    elif closer.kind() != ')':
        raise Exception( 'expected ")" to close macro parameters in macro starting at: %s, found: %s' % (
            repr( initial ),
            repr( closer  ),
        ))
    
    return parameters

def parse_macro_parameters(
    initial ,
    tokens  ,
):
    parameters = []
    while True:
        parameter = parse_macro_parameter(
            initial = initial ,
            tokens  = tokens  ,
        )
        if parameter == None:
            break
        
        parameters.append( parameter )
    
    return parameters

def parse_macro_parameter(
    initial ,
    tokens  ,
):
    name = tokens.peek()
    if not name:
        return
    elif name.kind() == ')':
        return
    elif name.kind() not in [ 'macrovar', '(' ]:
        raise Exception( 'expected a macrovar in macro parameters of macro definition at %s, found: %s' % (
            repr( initial ) ,
            repr( name    ) ,
        ))
    
    if name.kind() == '(':
        with print_on_exception( 'while parsing macro parameters starting at %s' % repr( initial ) ):
            parameterList = parse_macro_parameter_list(
                initial = initial ,
                tokens  = tokens  ,
            )
            
            return MacroParameter(
                initial  = name ,
                namer    = NamerMacroList(
                    parameterList = parameterList ,
                ),
                expander = ExpanderMacroList(
                    parameterList = parameterList ,
                ),
            )
        
        raise Exception( 'there it is' )
    
    tokens.take()
    
    bits = name.value().split(".")
    
    expander = ExpanderScalar()
    
    parameter = MacroParameter(
        initial  = name                          ,
        namer    = NamerScalar( name = bits[0] ) ,
        expander = expander                      ,
    )
    
    expansionRules = {
        'each'          : ExpansionRuleEach          ,
        'count'         : ExpansionRuleCount         ,
        'first'         : ExpansionRuleFirst         ,
        'rest'          : ExpansionRuleRest          ,
        'toZero'        : ExpansionRuleToZero        ,
        'toOne'         : ExpansionRuleToOne         ,
        'decr'          : ExpansionRuleDecr          ,
        'incr'          : ExpansionRuleIncr          ,
        'expandIf'      : ExpansionRuleExpandIf      ,
        'expandIfNot'   : ExpansionRuleExpandIfNot   ,
        'ifNotEmpty'    : ExpansionRuleIfNotEmpty    ,
        'ifEqual'       : ExpansionRuleIfEqual       ,
        'ifLessThan'    : ExpansionRuleIfLessThan    ,
        'ifGreaterThan' : ExpansionRuleIfGreaterThan ,
        'collect'       : ExpansionRuleCollect       ,
        
        'expandno'      : ExpansionRuleExpandNo      ,
        'globalno'      : ExpansionRuleGlobalNo      ,
    }
    
    for bit in bits[1:]:
        if bit in expansionRules:
            expander.add_expansion_rule( expansionRules[ bit ], location = name.location() )
        else:
            raise Exception( 'unknown expansion rule: %s' % repr( bit ) )
    
    return parameter

class MacroParameter:
    def __init__(
        self     ,
        initial  ,
        namer    ,
        expander ,
    ):
        self._initial  = initial
        self._namer    = namer
        self._expander = expander
        return
    
    def __repr__(
        self ,
    ):
        return '<MacroParameter namer=%s expander=%s>' % (
            repr( self._namer    ) ,
            repr( self._expander ) ,
        )
    
    def namer( self ):
        return self._namer
    
    def expander( self ):
        return self._expander
    
    def consumes_argument( self ):
        return self._expander.consumes_argument()
    
    def simple( self ):
        return '<macro-parameter namer=%s>' % self._namer.simple()

class Variations:
    def __init__(
        self  ,
        value ,
    ):
        self._values = [ value ]
    
    def variations(
        self ,
    ):
        for value in self._values:
            yield value

class ExpanderScalar:
    def __init__(
        self ,
    ):
        self._expansionRules = []
        return
    
    def expansion_rules( self ):
        for rule, location in self._expansionRules:
            yield rule
    
    def add_expansion_rule( self, rule, location ):
        return self._expansionRules.append( (rule, location) )
    
    def consumes_argument( self ):
        if not self._expansionRules:
            return True
        else:
            return self._expansionRules[0][0].consumes_argument()
    
    def argument_consuming_variations( self, value ):
        source = Variations( value )
        for rule, location in self._expansionRules:
            source = rule(
                location = location ,
                source   = source   ,
            )
        
        for variation in source.variations():
            yield variation
    
    def non_argument_consuming_variations( self ):
        if self.consumes_argument():
            raise Exception( 'nonconsuming variations should not be called for an argument consuming parameter' )
        else:
            rule, location = self._expansionRules[0]
            source = rule( location = location )
            for rule, location in self._expansionRules[1:]:
                source = rule(
                    location = location ,
                    source   = source   ,
                )
            
            for variation in source.variations():
                yield variation

class NamerScalar:
    def __init__(
        self ,
        name ,
    ):
        self._name = name
    
    def names( self, value ):
        yield (self._name, value)
        
    def simple( self ):
        return '<scalar-namer %s>' % repr( self._name )

class ExpanderMacroList:
    def __init__(
        self          ,
        parameterList ,
    ):
        self._parameterList = parameterList
        return
    
    def consumes_argument( self ):
        return True
    
    def argument_consuming_variations( self, value ):
        
        if value.kind() != 'macrolist':
            raise Exception( 'cannot deconstruct a non-macrolist: %s' % repr( value ) )
        
        bits = value.bits()
        
        if len( bits ) == 0:
            yield MacroList(
                location = value.location() ,
                bits     = []               ,
            )
            return
        
        if len( bits ) != len( self._parameterList ):
            raise Exception( 'expected macrolist to have %s entries: %s' % (
                len( self._parameterList ) ,
                repr( value )              ,
            ))
        
        mapping = []
        index   = 0
        for parameter in self._parameterList:
            if parameter.consumes_argument():
                mapping.append(
                    (lambda which: lambda: parameter.expander().argument_consuming_variations( bits[which] ))( index )
                )
                index += 1
            else:
                mapping.append(
                    lambda: parameter.expander().non_argument_consuming_variations()
                )
        
        root  = mapping[0]()
        first = next( root, None )
        if first == None:
            return
        
        walk = [ [root,first] ]
        
        while True:
            
            # add additional items to fill out the structure
            # 
            while len( walk ) < len( bits ):
                ii = len( walk )
                ss = mapping[ii]()
                vv = next( ss, None )
                if vv == None:
                    break
                else:
                    walk.append( [ss,vv] )
            
            # if we filled a tuple, pass it out
            if len( walk ) == len( bits ):
                mm = MacroList(
                    location = value.location()               ,
                    bits     = list( bb for (aa,bb) in walk ) ,
                )
                yield mm
            
            # update the rearmost item
            # remove it if it returns none
            # repeat.
            # 
            while walk:
                vv = next( walk[-1][0], None )
                if vv == None:
                    walk.pop()
                    continue
                else:
                    walk[-1][1] = vv
                    break
            
            # stop if the initial variation returned none and was therefore removed
            if not walk:
                break
        
        return
        
class NamerMacroList:
    def __init__(
        self          ,
        parameterList ,
    ):
        self._parameterList = parameterList
        return
    
    def names( self, value ):
        
        if value.kind() != 'macrolist':
            raise Exception( 'expected a macrolist, got: %s' % repr( value ) )
        
        if len( self._parameterList ) != len( value.bits() ):
            raise Exception( 'during expansion macro-list should have %s slots, instead found: %s' % (
                str( len( self._parameterList ) ) ,
                repr( value )                     ,
            ))
        
        for pp, vv in zip( self._parameterList, value.bits() ):
            for naming in pp.namer().names( vv ):
                yield naming
    
    def simple( self ):
        return '<macrolist-namer %s>' % repr([ pp.namer().simple() for pp in self._parameterList ])

class ExpansionRuleEach:
    @staticmethod
    def consumes_argument():
        return True
    
    def __init__(
        self     ,
        location ,
        source   ,
    ):
        self._location = location
        self._source   = source
        
    def variations( self ):
        for value in self._source.variations():
            
            if value.kind() != 'macrolist':
                raise Exception( '.each expected macrolist, found: %s' % repr( value ) )
            
            for bit in value.bits():
                yield bit

class ExpansionRuleCount:
    @staticmethod
    def consumes_argument():
        return True
    
    def __init__(
        self     ,
        location ,
        source   ,
    ):
        self._location = location
        self._source   = source
        return
    
    def variations(
        self ,
    ):
        for value in self._source.variations():
            if value.kind() != 'macrolist':
                raise Exception( '.count expected macrolist, found %s' % repr( value ) )
            
            cc = len( list( value.bits() ) )
            
            yield Token(
                location = self._location ,
                kind     = 'integer'      ,
                value    = cc             ,
            )

class ExpansionRuleFirst:
    @staticmethod
    def consumes_argument():
        return True
    
    def __init__(
        self     ,
        location ,
        source   ,
    ):
        self._location = location
        self._source   = source
    
    def variations(
        self ,
    ):
        for value in self._source.variations():
            if value.kind() != 'macrolist':
                raise Exception( '.first expected a macrolist, found %s' % repr( value ) )
            
            if value.bits():
                yield value.bits()[0]
            else:
                raise Exception( '.first received a macrolist with no entries: %s' % repr( value ) )
    
class ExpansionRuleRest:
    @staticmethod
    def consumes_argument():
        return True
    
    def __init__(
        self     ,
        location ,
        source   ,
    ):
        self._location = location
        self._source   = source
    
    def variations(
        self ,
    ):
        for value in self._source.variations():
            if value.kind() != 'macrolist':
                raise Exception( '.rest expected a macrolist, found %s' % repr( value ) )
            
            if value.bits():
                yield MacroList(
                    location = value.location() ,
                    bits     = value.bits()[1:] ,
                )
            else:
                raise Exception( '.rest received a macrolist with no entries: %s' % repr( value ) )

class ExpansionRuleToZero:
    @staticmethod
    def consumes_argument():
        return True
    
    def __init__(
        self     ,
        location ,
        source   ,
    ):
        self._location = location
        self._source   = source
        
    def variations( self ):
        
        for value in self._source.variations():
            
            if value.kind() != 'integer':
                raise Exception( '.toZero received non-integer: %s' % repr( value ) )
            
            new = value.value() - 1
            
            if new > 0:
                while new >= 0:
                    yield Token(
                        location = value.location() ,
                        kind     = 'integer'        ,
                        value    = new              ,
                    )
                    new -= 1

class ExpansionRuleToOne:
    @staticmethod
    def consumes_argument():
        return True
    
    def __init__(
        self     ,
        location ,
        source   ,
    ):
        self._location = location
        self._source   = source
    
    def variations( self ):
        for value in self._source.variations():
            if value.kind() != 'integer':
                raise Exception( '.toOne received non-integer: %s' % repr( value ) )
            new = value.value()
            if new > 1:
                while new >= 1:
                    yield Token(
                        location = value.location() ,
                        kind     = 'integer'        ,
                        value    = new              ,
                    )
                    new -= 1

class ExpansionRuleDecr:
    
    @staticmethod
    def consumes_argument():
        return True
    
    def __init__(
        self     ,
        location ,
        source   ,
    ):
        self._location = location
        self._source   = source
    
    def variations( self ):
        for value in self._source.variations():
            if value.kind() != 'integer':
                raise Exception( '.decr received non-integer: %s' % repr( value ) )
            else:
                new = value.value() - 1
                yield Token(
                    location = value.location() ,
                    kind     = 'integer'        ,
                    value    = new              ,
                )

class ExpansionRuleIncr:
    @staticmethod
    def consumes_argument():
        return True
    
    def __init__(
        self     ,
        location ,
        source   ,
    ):
        self._location = location
        self._source   = source
    
    def variations( self ):
        for value in self._source.variations():
            if value.kind() != 'integer':
                raise Exception( '.incr received non-integer: %s' % repr( value ) )
            else:
                new = value.value() + 1
                yield Token(
                    location = value.location() ,
                    kind     = 'integer'        ,
                    value    = new              ,
                )

class ExpansionRuleExpandIf:
    # truthiness: anything not 0 () or ""
    @staticmethod
    def consumes_argument():
        return True
    
    def __init__(
        self     ,
        location ,
        source   ,
    ):
        self._location = location
        self._source   = source
        
    def variations( self ):
        for value in self._source.variations():
            if value.kind() == 'integer':
                if value.value():
                    yield value
            elif value.kind() == 'string':
                if value.value():
                    yield value
            elif value.kind() == 'macrolist':
                if value.bits():
                    yield value
            else:
                raise Exception( '.expandIf expects integers, strings or macrolists, found %s' % repr( value ) )
    
class ExpansionRuleExpandIfNot:
    # truthiness: anything not 0 () or ""
    @staticmethod
    def consumes_argument():
        return True
    
    def __init__(
        self     ,
        location ,
        source   ,
    ):
        self._location = location
        self._source   = source
        
    def variations( self ):
        for value in self._source.variations():
            if value.kind() == 'integer':
                if not value.value():
                    yield value
            elif value.kind() == 'string':
                if not value.value():
                    yield value
            elif value.kind() == 'macrolist':
                if not value.bits():
                    yield value
            else:
                raise Exception( '.expandIf expects integers, strings or macrolists, found %s' % repr( value ) )
    
class ExpansionRuleIfNotEmpty:
    @staticmethod
    def consumes_argument():
        return True
    
    def __init__(
        self     ,
        location ,
        source   ,
    ):
        self._location = location
        self._source   = source
        
    def variations(
        self ,
    ):
        for value in self._source.variations():
            if value.kind() != 'macrolist':
                raise Exception( '.ifNotEmpty expected a macrolist, found %s' % repr( value ) )
            
            if value.bits():
                yield value

class ExpansionRuleIfEqual:
    @staticmethod
    def consumes_argument():
        return True
    
    def __init__(
        self     ,
        location ,
        source   ,
    ):
        self._location = location
        self._source   = source
        
    def variations(
        self ,
    ):
        for value in self._source.variations():
            if value.kind() != 'macrolist':
                raise Exception( '.ifEqual expected a macrolist, found %s' % repr( value ) )
            
            last    = None
            isEqual = True
            for bit in value.bits():
                if bit.kind() not in [ 'string', 'integer' ]:
                    raise Exception( '.ifEqual only operates on macrolists of strings and integers, found %s' % repr( bit ) )
                if last == None:
                    last = bit
                else:
                    if bit.kind() != last.kind():
                        raise Exception( '.ifEqual does not allow mixing integers and strings, found %s after %s' % (
                            repr( bit     ) ,
                            repr( lastBit ) ,
                        ))
                    elif bit.value() == last.value():
                        # good
                        continue
                    else:
                        isEqual = False
                        break
            
            if isEqual:
                yield value
    
class ExpansionRuleIfLessThan:
    @staticmethod
    def consumes_argument():
        return True
    
    def __init__(
        self     ,
        location ,
        source   ,
    ):
        self._location = location
        self._source   = source
    
    def variations(
        self ,
    ):
        for value in self._source.variations():
            
            if value.kind() != 'macrolist':
                raise Exception( '.ifLessThan expected a macrolist, found %s' % repr( value ) )
            
            last = None
            isLesser = True
            for bit in value.bits():
                if bit.kind() != 'integer':
                    raise Exception( '.ifLessThan expected macrolist to contain integers, found %s' % repr( bit ) )
                elif last == None:
                    last = bit
                else:
                    if not ( last.value() < bit.value() ):
                        isLesser = False
                        break
            
            if isLesser:
                yield value

class ExpansionRuleIfGreaterThan:
    @staticmethod
    def consumes_argument():
        return True
    
    def __init__(
        self     ,
        location ,
        source   ,
    ):
        self._location = location
        self._source   = source
        
    def variations(
        self ,
    ):
        for value in self._source.variations():
            
            if value.kind() != 'macrolist':
                raise Exception( '.ifGreaterThan expected a macrolist, found %s' % repr( value ) )
            
            last = None
            isGreater = True
            for bit in value.bits():
                if bit.kind() != 'integer':
                    raise Exception( '.ifGreaterThan expected macrolist to contain integers, found %s' % repr( bit ) )
                elif last == None:
                    last = bit
                else:
                    if not ( last.value() > bit.value() ):
                        isGreater = False
                        break
            
            if isGreater:
                yield value

# gathers all variations of its source into a macrolist
class ExpansionRuleCollect:
    @staticmethod
    def consumes_argument():
        return True
    
    def __init__(
        self     ,
        location ,
        source   ,
    ):
        self._location = location
        self._source   = source
        return
    
    def variations(
        self ,
    ):
        bits = []
        for value in self._source.variations():
            bits.append( value )
        
        yield MacroList(
            location = self._location ,
            bits     = bits           ,
        )

# due to the way expansion currently operates, this doesn't do anything at all
# it either spits out a single 0 which is used and reused by the following parameter expansions
#   or it is instantiated anew for each combination of other parameter expansions.
# to make it useful, it would need to be able to access data from the expansion process
#   we'll need to introduce some way for it to communicate with the code performing the
#   expansions at that location.
# I don't care right now, so I'll just leave this reminder
class ExpansionRuleExpandNo:
    @staticmethod
    def consumes_argument():
        return False
    
    def __init__(
        self     ,
        location ,
    ):
        self._location = location
        self._nn       = 0
    
    def variations( self ):
        nn = self._nn
        self._nn += 1
        
        yield Token(
            location = self._location ,
            kind     = 'integer'      ,
            value    = nn             ,
        )

class ExpansionRuleGlobalNo:
    NN = [1]
    
    @staticmethod
    def consumes_argument():
        return False
    
    def __init__(
        self     ,
        location ,
    ):
        self._location = location
    
    def variations( self ):
        nn = self.NN[0]
        self.NN[0] += 1
        yield Token(
            location = self._location ,
            kind     = 'integer'      ,
            value    = nn             ,
        )

def parse_unexpanded_definitions(
    tokens        ,
    currentModule ,
):
    unexpandedDefinitions = []
    while True:
        unexpandedDefinition = parse_unexpanded_definition(
            tokens        = tokens        ,
            currentModule = currentModule ,
        )
        if not unexpandedDefinition:
            break
        else:
            unexpandedDefinitions.append( unexpandedDefinition )
    return unexpandedDefinitions

def parse_unexpanded_definition(
    tokens        ,
    currentModule ,
):
    start = tokens.peek()
    if not start:
        return
    elif start.kind() == ';':
        return
    elif not ( start.kind() == ':' or start.kind() == '@' ):
        raise Exception(
            'expected ":" or "@" to start definition expansions, instead found: %s' % repr( start )
        )
    
    tokens.take()
    
    with print_on_exception( 'while scanning in unexpanded definition starting at %s' % repr( start ) ):
        bits = capture_balanced_bits_til_terminator( tokens )
    
    end = tokens.take()
    if not end:
        raise Exception( 'missing expected ";" to terminate statement starting with: %s' % repr( start ) )
    elif end.kind() != ';':
        raise Exception( 'missing expected ";" to terminate statement starting with %s, instead found: %s' % (
            repr( start ) ,
            repr( end   ) ,
        ))
    
    bits.append( end )
    
    if start.kind() == ':':
        return UnexpandedFunctionDefinition(
            initial       = start         ,
            bits          = bits          ,
            currentModule = currentModule ,
        )
    elif start.kind() == '@':
        return UnexpandedMacroExpansion(
            initial       = start         ,
            bits          = bits          ,
            currentModule = currentModule ,
        )
    else:
        raise Exception( 'not sure what this is: %s' % repr( start ) )

def capture_balanced_bits_til_terminator(
    tokens ,
):
    depthStack = []
    bits = []
    while True:
        bit = tokens.peek()
        if bit == None:
            raise Exception(
                'ran out of tokens while collecting statement: firstbit=%s' % repr( (bits and bits[0]) or None )
            )
        
        if bit.kind() in [ '[', '{', '(' ]:
            tokens.take()
            bits.append( bit )
            depthStack.append( bit )
        elif bit.kind() in [ ']', '}', ')' ]:
            if depthStack:
                tokens.take()
                bits.append( bit )
                matches = { '[' : ']', '{' : '}', '(' : ')' }
                if matches[ depthStack[-1].kind() ] == bit.kind():
                    depthStack.pop()
                else:
                    raise Exception( 'expected "%s" to match %s, instead found: %s' % (
                        matches[ depthStack[-1].kind() ] == bit.kind() ,
                        repr( depthStack[-1] )                         ,
                        repr( bit )                                    ,
                    ))
            else:
                # do not take!
                break
        elif bit.kind() == ';':
            if depthStack:
                raise Exception( 'unterminated "%s" starting at: %s' % (
                    depthStack[-1].kind()  ,
                    repr( depthStack[-1] ) ,
                ))
            else:
                # do not take!
                break
        else:
            tokens.take()
            bits.append( bit )
            pass
    
    return bits

class UnexpandedFunctionDefinition:
    def __init__(
        self          ,
        initial       ,
        bits          ,
        currentModule ,
    ):
        self._initial       = initial
        self._bits          = bits
        self._currentModule = currentModule
        return
    
    def initial( self ):
        return self._initial
    
    def bits( self ):
        return self._bits
    
    def current_module( self ):
        return self._currentModule

class UnexpandedMacroExpansion:
    def __init__(
        self          ,
        initial       ,
        bits          ,
        currentModule ,
    ):
        self._initial       = initial
        self._bits          = bits
        self._currentModule = currentModule
        return
    
    def initial( self ):
        return self._initial
    
    def bits( self ):
        return self._bits
    
    def current_module( self ):
        return self._currentModule

def parse_named_macro_expansion(
    initial       ,
    tokens        ,
    currentModule ,
    macroContext  ,
    uniques       ,
):
    # not expanding it yet, just recording the invocation so we can expand it later
    # the @ is in initial
    # 
    #   @ macro-name macro arguments (can be lists) [ or lamdbas ] ;
    # 
    
    name = tokens.take()
    if not name:
        raise Exception( 'expected name of macro to expand to follow macro expansion sigil at: %s' % repr( initial ) )
    elif name.kind() != 'word':
        raise Exception( 'expected name of macro to expand to follow macro expansion sigil at %s, instead found: %s' % (
            repr( initial ) ,
            repr( name    ) ,
        ))
    
    with print_on_exception(
        'while scanning for named macro expansion arguments for expansion starting at: %s' % (
            repr( initial )
        )
    ):
        argumentBits = capture_balanced_bits_til_terminator(
            tokens ,
        )
        
        argumentBitsSource = Source( argumentBits )
        
        expandedArgumentBits = expand_bitstream(
            macroContext = macroContext      ,
            tokens      = argumentBitsSource ,
            uniques     = uniques            ,
        )
        
        expandedArgumentBitsSource = Source( expandedArgumentBits )
        
        arguments = parse_macro_expansion_arguments(
            initial = initial                    ,
            tokens  = expandedArgumentBitsSource ,
        )
    
    closer = tokens.take()
    if not closer:
        raise Exception( 'expected ";" to close macro expansion at: %s' % repr( initial ) )
    elif closer.kind() != ';':
        raise Exception( 'expected ";" to close macro expansion at: %s, instead found: %s' % (
            repr( initial ) ,
            repr( closer  ) ,
        ))
    
    return NamedMacroExpansion(
        initial   = initial   ,
        macroName = name      ,
        arguments = arguments ,
    )

class NamedMacroExpansion:
    def __init__(
        self      ,
        initial   ,
        macroName ,
        arguments ,
    ):
        self._initial   = initial
        self._macroName = macroName
        self._arguments = arguments
        return
    
    def __repr__(
        self ,
    ):
        return '<NamedMacroExpansion name=%s arguments=%s>' % (
            repr( self._macroName ) ,
            repr( self._arguments ) ,
        )
    
    def simple(
        self ,
    ):
        return '@ %s ( %s )' % (
            self._macroName.simple()                            ,
            ' '.join( arg.simple() for arg in self._arguments ) ,
        )
    
    def initial( self ):
        return self._initial
    
    def definition_type( self ):
        return 'named-macro-expansion'
    
    def macro_name( self ):
        return self._macroName
    
    def arguments( self ):
        return self._arguments

def parse_macro_expansion_arguments(
    initial ,
    tokens  ,
):
    arguments = []
    
    while True:
        argument = parse_macro_expansion_argument(
            initial = initial ,
            tokens  = tokens  ,
        )
        if not argument:
            break
        else:
            arguments.append( argument )
    
    return arguments

def parse_macro_expansion_argument(
    initial ,
    tokens  ,
):
    # name
    # @name 
    # number
    # "string"
    # [ all of the above ]
    # ( all of the above )
    
    pp = tokens.peek()
    if pp == None:
        return
    elif pp.kind() == ';':
        return
    elif pp.kind() in [ ')', ']' ]:
        return
    
    tokens.take()
    
    if pp.kind() in [ 'word', 'macrovar', 'integer', 'string', 'macrolist' ]:
        return pp
    
    elif pp.kind() == '[':
        bits = parse_macro_expansion_arguments(
            initial ,
            tokens  ,
        )
        
        closer = tokens.take()
        if not closer:
            raise Exception( 'unterminated lambda statement starting at: %s' % repr( pp ) )
        elif closer.kind() != ']':
            raise Exception( 'expected "]" to close lambda at %s, instead found: %s' % (
                repr( pp     ) ,
                repr( closer ) ,
            ))
        
        return ExpandableLambda( pp, bits )
    
    elif pp.kind() == '(':
        bits = parse_macro_expansion_arguments(
            initial ,
            tokens  ,
        )
        
        closer = tokens.take()
        if not closer:
            raise Exception( 'unterminated macro-list starting at: %s' % repr( pp ) )
        elif closer.kind() != ')':
            raise Exception( 'expected ")" to close macro-list at %s, instead found: %s' % (
                repr( pp     ) ,
                repr( closer ) ,
            ))
        
        return MacroList(
            location = pp.location() ,
            bits     = bits          ,
        )
    else:
        raise Exception( 'unknown bit in macro expansion variables: %s' % repr( pp ) )
    
class MacroList:
    def __init__(
        self     ,
        location ,
        bits     ,
    ):
        self._location = location
        self._bits     = bits
    
    def __repr__(
        self ,
    ):
        return '<MacroList contents=%s>' % repr( self._bits )
    
    def simple(
        self ,
    ):
        return '( %s )' % (
            ' '.join( str( bit.simple() ) for bit in self._bits ) ,
        )
    
    def kind( self ):
        return 'macrolist'
    
    def location( self ):
        return self._location
    
    def bits( self ):
        return self._bits

#####

def expand_macros(
    namedMacroExpansions ,
    macroContext         ,
    uniques              ,
):
    for macroExpansion in namedMacroExpansions:
        fns = expand_macro(
            macroExpansion = macroExpansion ,
            macroContext   = macroContext   ,
            uniques        = uniques        ,
        )
        for fn in fns:
            yield fn
    
def expand_macro(
    macroExpansion ,
    macroContext   ,
    uniques        ,
):
    if G_SHOW_EXPANSIONS:
        log( 'EXPANDING-NAMED', macroExpansion.simple() )
    
    if not macroContext.has_macro( macroExpansion.macro_name().value() ):
        raise Exception( 'unknown macro definition: %s' % macroExpansion.macro_name() )
    
    md = macroContext.get_macro( macroExpansion.macro_name().value() )
    
    expansions = determine_macro_expansions(
        macroStart = macroExpansion.initial()           ,
        parameters = md.parameters()                    ,
        arguments  = list( macroExpansion.arguments() ) ,
    )
    
    expandedFunctions = []
    for group in expansions:
        
        expansionContext = macroContext.copy()
        
        for (name, value) in group:
            expansionContext.add_macrovar( name, value )
        
        for unexpandedDefinition in md.unexpanded_definitions():
            
            if unexpandedDefinition.initial().kind() == ':':
                expandedBits = expand_bitstream(
                    macroContext = expansionContext                      ,
                    tokens       = Source( unexpandedDefinition.bits() ) ,
                    uniques      = uniques                               ,
                )
                expandedFunction = parse_named_function(
                    initial       = unexpandedDefinition.initial()        ,
                    tokens        = Source( expandedBits )                ,
                    currentModule = unexpandedDefinition.current_module() ,
                    macroContext  = macroContext                          ,
                    uniques       = uniques                               ,
                )
                expandedFunctions.append( expandedFunction )
                if G_SHOW_EXPANSIONS:
                    log( 'EXPANDED-FUNCTION', expandedFunction.simple() )
                
            elif unexpandedDefinition.initial().kind() == '@': # or macrovar?
                
                expandedBits = expand_bitstream(
                    macroContext = expansionContext                      ,
                    tokens       = Source( unexpandedDefinition.bits() ) ,
                    uniques      = uniques                               ,
                )
                expandedExpansion = parse_named_macro_expansion(
                    initial       = unexpandedDefinition.initial()        ,
                    tokens        = Source( expandedBits )                ,
                    currentModule = unexpandedDefinition.current_module() ,
                    macroContext  = macroContext                          ,
                    uniques       = uniques                               ,
                )
                for fn in expand_macro(
                    macroExpansion = expandedExpansion ,
                    macroContext   = macroContext      ,
                    uniques        = uniques           ,
                ):
                    expandedFunctions.append( fn )
                
            else:
                raise Exception(
                    'unknown unexpanded definition type in macro expansion: %s' % (
                        repr( unexpandedDefinition.initial() ) ,
                    )
                )
    
    return expandedFunctions

def determine_macro_expansions(
    macroStart ,
    parameters ,
    arguments  ,
):
    argSource = Source( arguments )
    
    nArgParams = sum( 1 for param in parameters if param.consumes_argument() )
    nArgs      = len( arguments )
    if nArgParams != nArgs:
        raise Exception(
            'macro expansion has %s argument consuming parameters, but received %s arguments at %s' % (
                repr( nArgParams ) ,
                repr( nArgs      ) ,
                repr( macroStart ) ,
            )
        )
    
    expansionArgSources = []
    for param in parameters:
        if param.consumes_argument():
            arg = argSource.take()
            if arg == None:
                raise Exception(
                    'expansion at %s lacks argument for macro parameter: %s' % (
                        repr( macroStart ) ,
                        param.name()       ,
                    )
                )
            else:
                expansionArgSources.append( NamedArgSource(
                    namer    = param.namer()    ,
                    expander = param.expander() ,
                    source   = arg              ,
                ))
        else:
            expansionArgSources.append( NamedNonArgSource(
                namer    = param.namer()    ,
                expander = param.expander() ,
            ))
    
    return chain_argument_sources( expansionArgSources )

def chain_argument_sources( sources, _left = None ):
    _left = _left or ()
    if sources:
        source, remaining = sources[0], sources[1:]
        for vv in source.variations():
            if remaining:
                for group in chain_argument_sources( remaining, _left + tuple( source.namer().names( vv ) ) ):
                    yield group
            else:
                chained = _left + tuple( source.namer().names( vv ) )
                # if G_SHOW_EXPANSIONS:
                #     log( 'CHAINED', chained )
                yield chained
    else:
        yield _left

class NamedArgSource:
    def __init__(
        self     ,
        namer    ,
        expander ,
        source   ,
    ):
        self._namer    = namer
        self._expander = expander
        self._source   = source
        return
    
    def namer(
        self ,
    ):
        return self._namer
    
    def variations(
        self ,
    ):
        return self._expander.argument_consuming_variations( self._source )
    
class NamedNonArgSource:
    def __init__(
        self     ,
        namer    ,
        expander ,
    ):
        self._namer    = namer
        self._expander = expander
        return
    
    def namer(
        self ,
    ):
        return self._namer
    
    def variations(
        self ,
    ):
        return self._expander.non_argument_consuming_variations()

def expand_bitstream(
    macroContext ,
    tokens       ,
    uniques      ,
):
    while True:
        bit = tokens.take()
        if not bit:
            break
        elif bit.kind() == 'macrovar':
            yield macroContext.expand_macrovar( bit )
        elif bit.kind() == '@':
            if G_SHOW_EXPANSIONS:
                EXPANSIONID = G_EXPANSION_ID[0]
                G_EXPANSION_ID[0] += 1
                EXPANDED = []
            else:
                EXPANSIONID = 'NOT-EXPANDING'
            for bit in extract_and_expand_local_macro(
                macroContext = macroContext ,
                tokens       = tokens       ,
                expansionId  = EXPANSIONID  ,
                uniques      = uniques      ,
            ):
                if G_SHOW_EXPANSIONS:
                    EXPANDED.append( bit )
                yield bit
            if G_SHOW_EXPANSIONS:
                log( 'EXPANDED-LOCAL', 'XID=', EXPANSIONID, 'TO', repr(' '.join([ E.simple() for E in EXPANDED ])) )
        elif bit.kind() == 'macrostring':
            yield expand_macrostring(
                macroContext = macroContext ,
                macroString  = bit          ,
            )
        elif bit.kind() == 'macrocode':
            yield expand_macrocode(
                macroContext = macroContext ,
                macroCode    = bit          ,
            )
        elif bit.kind() == 'macrolist':
            yield MacroList(
                location = bit.location()                 ,
                bits     = list(expand_bitstream(
                    macroContext = macroContext ,
                    tokens       = Source( bit.bits() ) ,
                    uniques      = uniques ,
                )),
            )
        elif bit.kind() in [ ';', '{', '}', '[', ']', '(', ')', 'localfn', 'word', 'integer', 'string', 'code', 'fnref' ]:
            yield bit
        else:
            raise Exception( 'unknown bit in macro expansion bitstream: %s' % repr( bit ) )

def expand_macrostring(
    macroContext ,
    macroString  ,
):
    if macroString.kind() != 'macrostring':
        raise Exception( 'impossible' )
    
    def replace( mm ):
        macrovar = mm.group('name')
        if macrovar == '@':
            return '@'
        if not macroContext.has_macrovar( macrovar ):
            raise Exception( 'while expanding macrostring (%s), missing macrovar: %s' % (
                repr( macroString ) ,
                repr( macrovar )    ,
            ))
        vv = macroContext.get_macrovar( macrovar )
        if vv.kind() == 'word':
            return vv.value()
        elif vv.kind() == 'integer':
            return str( vv.value() )
        elif vv.kind() == 'string':
            return vv.value()
        else:
            raise Exception( 'cannot interpolate macrostring (%s), macrovar (%s) is a %s' % (
                repr( macroString ) ,
                repr( macrovar )    ,
                str( vv.kind() )    ,
            ))
    
    interpolated = re.sub( '(?P<name>[@][A-Za-z][A-Za-z0-9]*)[@]', replace, macroString.value() )
    
    return Token(
        location = macroString.location() ,
        kind     = 'string'               ,
        value    = interpolated           ,
    )

def expand_macrocode(
    macroContext ,
    macroCode    ,
):
    if macroCode.kind() != 'macrocode':
        raise Exception( 'impossible' )
    
    def replace( mm ):
        macrovar = mm.group('name')
        if macrovar == '@':
            return ''
        if not macroContext.has_macrovar( macrovar ):
            raise Exception( 'while expanding macrocode (%s), missing macrovar: %s' % (
                repr( macroCode ) ,
                repr( macrovar )  ,
            ))
        vv = macroContext.get_macrovar( macrovar )
        if vv.kind() == 'word':
            return vv.value()
        elif vv.kind() == 'integer':
            return str( vv.value() )
        elif vv.kind() == 'string':
            return vv.value()
        else:
            raise Exception( 'cannot interpolate macrocode (%s), macrovar (%s) is a %s' % (
                repr( macroString ) ,
                repr( macrovar )    ,
                str( vv.kind() )    ,
            ))
    
    interpolated = re.sub( '(?P<name>[@][A-Za-z][A-Za-z0-9]*)[@]', replace, macroCode.value() )
    
    return Token(
        location = macroCode.location() ,
        kind     = 'code'               ,
        value    = interpolated         ,
    )

def extract_and_expand_local_macro(
    macroContext ,
    tokens       ,
    expansionId  ,
    uniques      ,
):
    # ( () () ... )
    # 
    #   argument expansion
    #   parameter interpretation
    #   body generation
    
    start = tokens.take()
    if not start:
        raise Exception( 'how did you even get here without a "(" ?' )
    elif start.kind() != '(':
        raise Exception( 'seriously, how without a "(" ?' )
    
    with print_on_exception( 'while parsing macro starting at: %s' % repr( start ) ):
        arguments = extract_local_macro_arguments(
            macroContext = macroContext ,
            tokens       = tokens       ,
            uniques      = uniques      ,
        )
        
        parameters = parse_macro_parameter_list(
            initial = start  ,
            tokens  = tokens ,
        )
        
        bodyBits = list( capture_balanced_bits_til_terminator(
            tokens ,
        ))
        
        if G_SHOW_EXPANSIONS:
            log(
                'EXPANDING-LOCAL', 'XID=', expansionId ,
                'arguments='     , repr(' '.join([ A.simple() for A in arguments  ])) ,
                'parameters='    , repr(' '.join([ P.simple() for P in parameters ])) ,
                'bodyBits='      , repr(' '.join([ B.simple() for B in bodyBits   ])) ,
            )
        
        end = tokens.take()
        if not end:
            raise Exception( 'missing ")" for macro starting at %s' % repr( start ) )
        elif end.kind() != ')':
            raise Exception( 'expected ")" for macro starting at %s, instead found: %s' % (
                repr( start ) ,
                repr( end )   ,
            ))
        
        for group in determine_macro_expansions(
            macroStart = start      ,
            parameters = parameters ,
            arguments  = arguments  ,
        ):
            expansionContext = macroContext.copy()
            
            for (name, value) in group:
                expansionContext.add_macrovar( name, value )
            
            bodyBitsSource = Source( bodyBits )
            
            expandedBody = expand_bitstream(
                macroContext = expansionContext ,
                tokens       = bodyBitsSource   ,
                uniques      = uniques          ,
            )
            
            for bit in expandedBody:
                yield bit
    
    return

def extract_local_macro_arguments(
    macroContext ,
    tokens       ,
    uniques      ,
):
    start = tokens.take()
    if not start:
        raise Exception( 'expected "(" to begin local-macro argument section' )
    elif start.kind() != '(':
        raise Exception( 'expected "(" to begin local-macro argument section, instead found: %s' % repr( start ) )
    
    argumentBits = capture_balanced_bits_til_terminator(
        tokens ,
    )
    
    argumentBitsSource = Source( argumentBits )
    
    expandedArgumentBits = list( expand_bitstream(
        macroContext = macroContext       ,
        tokens       = argumentBitsSource ,
        uniques      = uniques            ,
    ))
    
    expandedArgumentBitsSource = Source( expandedArgumentBits )
    
    macroArguments = parse_macro_expansion_arguments(
        initial = start                      ,
        tokens  = expandedArgumentBitsSource ,
    )
    
    # after because source is lazy
    # we have to give it a chance to be consumed
    trash = argumentBitsSource.take()
    if trash:
        raise Exception( 'failed to expand: %s' % repr( trash ) )
    
    trash = expandedArgumentBitsSource.take()
    if trash:
        raise Exception( 'failed to parse all expanded bits: %s' % repr( trash ) )
    
    end = tokens.take()
    if not end:
        raise Exception( 'expected ")" to end arguments section starting at: %s' % repr( start ) )
    elif end.kind() != ')':
        raise Exception( 'expected ")" to end arguments section starting at %s, instead found: %s' % (
            repr( start ) ,
            repr( end   ) ,
        ))
    
    return macroArguments

#####

# ensures all required functions are defined
# returns list of all actually used functions
# 
# TODO: use a tree starting from _start so we only get what we really actually need
# this includes anything that's in any function ( because we just modified a scanner )
# 
def analyze_functions( allFns, startname ):
    
    callgraph = {}
    
    # scan everything and build a graph of what functions reference each other
    # 
    for fn, dd in allFns.items():
        if fn not in callgraph:
            callgraph[ fn ] = set()
        for cc in dd.body().commands():
            if cc.kind() == 'word':
                if (cc.value()) not in allFns:
                    raise Exception( 'unknown function called at %s in %s: %s' % (
                        cc.location() ,
                        repr( dd )    ,
                        repr( unmangle( cc.value() ) ),
                    ))
                else:
                    callgraph[ fn ].add( cc.value() )
            elif cc.kind() == 'string':
                pass
            elif cc.kind() == 'code':
                pass
            elif cc.kind() == 'integer':
                pass
            elif cc.kind() == 'localfn':
                pass
            elif cc.kind() == 'FORWARDJUMPIF':
                pass
            elif cc.kind() == 'JUMPTARGET':
                pass
            elif cc.kind() == 'fnref':
                if cc.value() not in allFns:
                    raise Exception( 'address of unknown function taken in %s: %s' % ( repr( dd ), repr( cc ) ) )
                else:
                    callgraph[ fn ].add( cc.value() )
            elif cc.kind() == 'subfn':
                if cc.value() not in allFns:
                    raise Exception( 'missing lambda in %s: %s' % ( repr( dd ), repr( cc ) ) )
                else:
                    callgraph[ fn ].add( cc.value() )
            else:
                raise Exception( 'unexpected command form: %s' % repr( cc ) )
    
    # they have to define a :_start function
    # by default, it's in the library/STANDARD
    # and calls :main after initialization
    # 
    if startname not in allFns:
        raise Exception( 'no %s function ( forget to @ "STANDARD" ; ? )' % repr( unmangle( startname ) ) )
    
    # walk from :_start down and figure out what
    # functions are actually used in the current
    # program
    # 
    usedFns = set()
    pending = [ startname ]
    while pending:
        pp = pending.pop()
        if pp in usedFns:
            continue
        else:
            usedFns.add( pp )
            for callee in callgraph[ pp ]:
                pending.append( callee )
    
    return callgraph, usedFns

#####

class StringCoalescer:
    def __init__(
        self ,
    ):
        self._string2label = {}
        return
    
    def lookup( self, ss ):
        return self._string2label.get( ss, None )
        
    def remember( self, ss, label ):
        self._string2label[ ss ] = label


#####

# possible opts
# 
# constant propagation:
#   if a function just produces a constant, replace it with that constant in the caller
# function inlining:
#   if a function doesn't recurse
#   and is under some threshold for number of commands used in the callee
#   inline its locals and commands into the calling function
# branch pruning
#   if a conditional call would work against a constant, replace it with the call or a pop
# unused local/constant pruning
#   if a local or constant isn't used, don't bother to set it
# call pruning
#   if a function is side effect free and its value isn't used, don't bother to call it
# return elision:
#   if a function does not have any locals
#   tail call to the last function called in that function
#   flattens the return stack avoid unnecessary return chains
# assembly register and constant alternatives
#   a syntax for annotating assembly segments with short code segments
#   that can be used for replacing it with alternate code or constants
#   where appropriate

# immediately triggering the other function to run is dumb
# it makes writing simple loops a pain
# it should still wait for the next, just with a value set to return
# otherwise it makes writing logic for it unnecessarily hairy
# 
class NotStupidCoroutine:
    def __init__(
        self   ,
        actual ,
    ):
        self._actual  = iter(actual)
        self._pending = ()
    
    def __iter__( self ):
        return self
    
    def __next__( self ):
        if self._pending:
            p = self._pending[0]
            self._pending = None
            return self._actual.send(p)
        else:
            return next(self._actual)
    
    def prepare_send( self, value ):
        if self._pending:
            raise Exception( 'cannot stage yield-expression value when already set' )
        else:
            self._pending = (value,)

def optimize( allfns, used, callgraph, startname ):
    notes = {}
    opted = {}
    
    recursive = set()
    
    callees = callgraph
    callers = {}
    for (k,vv) in callees.items():
        for v in vv:
            if v not in callers:
                callers[v] = set()
            callers[v].add(k)
    
    pending = [(startname, NotStupidCoroutine(optimize_fn(
        notes     = notes             ,
        callees   = callees           ,
        callers   = callers           ,
        opted     = opted             ,
        allfns    = allfns            ,
        recursive = recursive         ,
        name      = startname         ,
        fn        = allfns[startname] ,
    )))]
    
    pendingNames = { startname }
    
    while pending:
        name, optgn = pending[-1]
        needed = next( optgn, None )
        if needed == None:
            pendingNames.remove(pending[-1][0])
            pending.pop()
            if pending:
                pending[-1][1].prepare_send(False)
        elif needed in opted:
            pending[-1][1].prepare_send(False)
        elif needed in pendingNames:
            pending[-1][1].prepare_send(True)
        else:
            pending.append( (needed,NotStupidCoroutine(optimize_fn(
                notes     = notes          ,
                callees   = callees        ,
                callers   = callers        ,
                opted     = opted          ,
                allfns    = allfns         ,
                recursive = recursive      ,
                name      = needed         ,
                fn        = allfns[needed] ,
            ))))
            pendingNames.add( needed )
    
    return opted

def optimize_fn( notes, callees, callers, opted, allfns, recursive, name, fn ):
    
    for command in fn.body().commands():
        
        if command.kind() == 'word':
            if (yield command.value()):
                recursive.add( command.value() )
        elif command.kind() == 'subfn':
            if (yield command.value()):
                recursive.add( command.value() )
        elif command.kind() == 'localfn':
            pass
        elif command.kind() == 'integer':
            pass
        elif command.kind() == 'code':
            pass
        elif command.kind() == 'string':
            pass
        elif command.kind() == 'fnref':
            pass
        else:
            raise Exception( 'unknown kind: %s' % repr( command.kind() ) )
    
    changed   = False
    updatedfn = fn
    while True:
        for optimizefn in [
            # optimize_constants ,
            # optimize_inline_nonrecursive_functions_of_less_than_threshold_commands_not_touching_the_control_stack ,
            # disabled: see note below optimize_tailcall_last_function_call_if_no_locals ,
            optimize_inline_nonrecursive,
            optimize_perform_token_replacements,
            optimize_propagate_localfn_constants,
        ]:
            changed, updatedfn = optimizefn(
                notes     = notes     ,
                recursive = recursive ,
                opted     = opted     ,
                name      = name      ,
                targetfn  = updatedfn ,
            )
        
        if changed:
            continue
        else:
            break
    
    opted[ name ] = updatedfn
    
    yield None

def optimize_constants( notes, recursive, opted, name, targetfn ):
    rewritten = []
    changed   = False
    for command in targetfn.body().commands():
        if command.kind() == 'word':
            if command.value() in notes and 'constant' in notes[ command.value() ]:
                if G_SHOW_OPTIMIZATIONS:
                    log( '[opt] replacing call in %s to %s with constant %s' % (
                        repr( unmangle( name ) )                     ,
                        repr( unmangle( command.value() ) )          ,
                        repr( notes[ command.value() ]['constant'].simple() ) ,
                    ))
                changed = True
                rewritten.append( notes[ command.value() ]['constant'] )
            else:
                rewritten.append( command )
        else:
            rewritten.append( command )
    
    if len( rewritten ) == 1 and rewritten[0].kind() in ['integer', 'string']:
        if name not in notes:
            notes[ name ] = {}
        notes[ name ]['constant'] = rewritten[0]
    
    if changed:
        return True, targetfn.rewriting_commands( rewritten )
    else:
        return False, targetfn

def optimize_inline_nonrecursive_functions_of_less_than_threshold_commands_not_touching_the_control_stack(
    notes     ,
    recursive ,
    opted     ,
    name      ,
    targetfn  ,
):
    rewritten = []
    changed   = False
    for command in targetfn.body().commands():
        if command.kind() == 'word':
            vv = command.value()
            isRecursive = vv in recursive
            # count commands and inline assembly bits
            isLong = (
                vv in opted
                and
                (
                    len( opted[vv].body().commands() )
                    +
                    sum(
                        len(e.value().split())
                        for e in opted[vv].body().commands()
                        if e.kind() == 'code'
                    )
                ) >= G_INLINE_THRESHOLD
            )
            hasLocals = vv in opted and len( opted[vv].body().localfns_names() ) > 0
            hasCodeTouchingTheCallStack = (
                vv in opted and any(
                    (e.kind() == 'code' and 'r15' in e.value())
                    for e in opted[vv].body().commands() 
                )
            )
            if isRecursive or isLong or hasLocals or hasCodeTouchingTheCallStack:
                # not optimizing it right now
                rewritten.append( command )
            else:
                if G_SHOW_OPTIMIZATIONS:
                    log( '[opt] inlining call to %s in %s' % ( repr( unmangle( command.value() ) ), repr( unmangle( name ) ) ) )
                # optimizing it!
                for subcommand in opted[vv].body().commands():
                    rewritten.append( subcommand )
    
    if changed:
        return True, targetfn.rewriting_commands( rewritten )
    else:
        return False, targetfn

# this actually makes runtime worse, lol
# probably nukes the return address prediction on the various return jumps
# 
def optimize_tailcall_last_function_call_if_no_locals(
    notes     ,
    recursive ,
    opted     ,
    name      ,
    targetfn  ,
):
    commands = targetfn.body().commands()
    if len( targetfn.body().localfns_names() ) == 0:
        if commands:
            if commands[-1].kind() == 'word':
                if G_SHOW_OPTIMIZATIONS:
                    log( '[opt] replacing call to %s at end of local-less function %s with jump' % (
                        repr( unmangle( commands[-1].value() ) ) ,
                        repr( unmangle( targetfn.name().value() ) ) ,
                    ))
                
                rewritten = list( commands )[:-1]
                rewritten.append( Token(
                    location = commands[-1].location() ,
                    kind     = 'fnref'                 ,
                    value    = commands[-1].value()    ,
                ))
                rewritten.append( Token(
                    location = commands[-1].location() ,
                    kind     = 'localfn'               ,
                    value    = '$.jump'                ,
                ))
                return True, targetfn.rewriting_commands( rewritten )
    
    return False, targetfn

INLINED_LEAVEIF = '''
    ; inlined leaveIf (--> jumpForward)
    sub r14, 8
    mov rax, [r14]
    test rax,rax
    jnz %(endlabel)s
'''

def optimize_inline_nonrecursive( notes, recursive, opted, name, targetfn ):
    
    rewritten = []
    newlocals = []
    
    nextno = 1
    
    changed = False
    
    for localvar in targetfn.body().localvars():
        newlocals.append( localvar )
    
    for command in targetfn.body().commands():
        
        if command.kind() == 'localfn' and command.value() == '$.noopt':
            if G_SHOW_OPTIMIZATIONS:
                debug('[inline-nonrecursive] refusing to optimize due to $.noopt in %s' % repr( unmangle( name ) ) )
            changed = False
            break
        
        if command.kind() == 'word':
            vv = command.value()
            isRecursive = vv in recursive
            hasCodeTouchingTheCallStack = (
                vv in opted and any(
                    (e.kind() == 'code' and 'r15' in e.value())
                    for e in opted[vv].body().commands()
                )
            )
            
            if isRecursive:
                if G_SHOW_OPTIMIZATIONS:
                    debug('[inline-nonrecursive] refusing to inline %s into %s because it is recursive' % (
                        repr( unmangle( vv ) ) ,
                        repr( unmangle( name ) ) ,
                    ))
                rewritten.append( command )
            elif hasCodeTouchingTheCallStack:
                # no optimization for you
                if G_SHOW_OPTIMIZATIONS:
                    debug('[inline-nonrecursive] refusing to inline into %s due to use of r15 in assembly in %s' % (
                        repr( unmangle( name ) ) ,
                        repr( unmangle( vv ) ) ,
                    ))
                rewritten.append( command )
            else:
                    
                if G_INLINE_ONLY:
                    m = G_INLINE_ONLY.match(unmangle( vv ))
                    if not m:
                        if G_SHOW_OPTIMIZATIONS:
                            debug('[inline-nonrecursive] refusing to inline %s, does not match --inline-only regex' % (
                                repr( unmangle( vv ) ),
                            ))
                        rewritten.append( command )
                        continue
                
                if G_INLINE_EXCEPT:
                    m = G_INLINE_EXCEPT.match(unmangle( vv ))
                    if m:
                        if G_SHOW_OPTIMIZATIONS:
                            debug('[inline-nonrecursive] refusing to inline %s, matches --inline-except regex' % (
                                repr( unmangle( vv ) ),
                            ))
                        rewritten.append( command )
                        continue
                
                if any( vv.kind() == 'localfn' and vv.value() == '$.noopt' for vv in opted[vv].body().commands() ):
                    if G_SHOW_OPTIMIZATIONS:
                        debug('[inline-nonrecursive] refusing to inline in to %s due to "$.noopt" in %s' % (
                            repr( unmangle( name ) ) ,
                            repr( unmange( vv ) ) ,
                        ))
                    rewritten.append( command )
                    continue
                else:
                    changed = True
                    
                    if G_SHOW_OPTIMIZATIONS:
                        log( '[inline-nonrecursive] inlining call to %s in %s' % (
                            repr( unmangle( command.value() ) ) ,
                            repr( unmangle( name ) ) ,
                        ))
                    
                    inlineno = nextno
                    nextno += 1
                    
                    end = '.' + vv + '.' + str(inlineno) + '.inline.end'
                    includeEndLabel = False
                    
                    for sublocal in opted[vv].body().localvars():
                        newlocals.append( ('$' + vv + '$' + str(inlineno) + sublocal[0], sublocal[1] ) )
                    
                    for subcommand in opted[vv].body().commands():
                        if subcommand.kind() == 'localfn' and subcommand.value()[:2] != '$.':
                            rewritten.append( Token(
                                location = subcommand.location()          ,
                                kind     = 'localfn'                      ,
                                value    = '$' + vv + '$' + str(inlineno) + subcommand.value() ,
                            ))
                        elif subcommand.kind() == 'localfn' and subcommand.value() == '$.leaveIf':
                            includeEndLabel = True
                            uniqueno = nextno
                            nextno += 1
                            rewritten.append( Token(
                                location = subcommand.location() ,
                                kind     = 'FORWARDJUMPIF'       ,
                                value    = end                   ,
                            ))
                        elif subcommand.kind() == 'code':
                            rewritten.append( Token(
                                location = subcommand.location() ,
                                kind     = 'code'                ,
                                value    = nest_labels( inlineno, vv, subcommand.value() ) ,
                            ))
                        elif subcommand.kind() == 'FORWARDJUMPIF':
                            rewritten.append( Token(
                                location = subcommand.location() ,
                                kind     = 'FORWARDJUMPIF'       ,
                                value    = '.' + vv + '.' + str(inlineno) + subcommand.value() ,
                            ))
                        elif subcommand.kind() == 'JUMPTARGET':
                            rewritten.append( Token(
                                location = subcommand.location() ,
                                kind     = 'JUMPTARGET'          ,
                                value    = '.' + vv + '.' + str(inlineno) + subcommand.value(),
                            ))
                        else:
                            rewritten.append( subcommand )
                    
                    if includeEndLabel:
                        rewritten.append( Token(
                            location = subcommand.location() ,
                            kind     = 'JUMPTARGET'          ,
                            value    = end                   ,
                        ))
        else:
            rewritten.append( command )
    
    if changed:
        return True, targetfn.rewriting_locals( newlocals ).rewriting_commands( rewritten )
    else:
        return False, targetfn

def nest_labels( uniqueno, prefix, code ):
    if '===' not in code:
        return nest_labels_munge( uniqueno, prefix, code )
    
    sections = parse_code_sections( IMPLEMENTATION, code )
    
    for section in sections:
        if not (section['headers'].get('impl',IMPLEMENTATION) == IMPLEMENTATION):
            continue
        elif not (section['headers'].get('type','code') == 'code'):
            continue
        else:
            section['body'] = nest_labels_munge( uniqueno, prefix, section['body'] )
    
    return unparse_code_sections( sections )
    
def nest_labels_munge( uniqueno, prefix, code ):
    
    isLocalLabel = re.compile( '(?P<before>.*)(?P<current>[.][A-Za-z_-]*)(?P<after>.*)' )
    
    rewritten = []
    for line in code.split("\n"):
        m = isLocalLabel.match( line )
        if m:
            rewritten.append(
                m.group('before')
                +
                '.' + prefix
                +
                '.' + str(uniqueno)
                + 
                m.group('current')
                + m.group('after')
            )
        else:
            rewritten.append( line )
    return '\n'.join(rewritten)

def optimize_perform_token_replacements( notes, recursive, opted, name, targetfn ):
    
    rewritten = []
    changed = False
    
    for command in targetfn.body().commands():
        if command.kind() != 'code':
            rewritten.append( command )
            continue
        
        if '===' not in command.value():
            rewritten.append( command )
            continue
        
        for section in parse_code_sections( IMPLEMENTATION, command.value() ):
            if not (section['headers'].get('impl', IMPLEMENTATION) == IMPLEMENTATION):
                if G_SHOW_OPTIMIZATIONS:
                    debug( '[token-replacements] skipping section, wrong impl: %s' % repr( section ) )
                continue
            
            if not (section['headers'].get('type','code') == 'token-replace'):
                if G_SHOW_OPTIMIZATIONS:
                    debug( '[token-replacements] skipping section, wrong type: %s' % repr( section ) )
                continue
            
            when = section['headers'].get('when', None)
            if when == None:
                raise Exception( 'you cannot have a rewrite rule with no when' )
            
            constraints = [ e.strip() for e in when.split(',') ]
            matches = True
            for index, constraint in enumerate( reversed( constraints ) ):
                if constraint == 'I':
                    if index >= len( rewritten ):
                        matches = False
                        break
                    elif rewritten[-index-1].kind() != 'integer':
                        matches = False
                        break
                else:
                    raise Exception( 'unknown when constraint: %s, in %s' % ( repr( constraint ), repr( command ) ) )
            
            if not matches:
                continue
            
            changed = True
            
            relevant = rewritten[-len(constraints):None]
            rewritten = rewritten[None:-len(constraints)]
            
            gs = globals().copy()
            gs['self'] = command
            todo = eval( section['body'], gs )
            
            new = todo( *relevant )
            
            if G_SHOW_OPTIMIZATIONS:
                log( '[token-replacements] replaced %s with %s' % (
                    (
                        tuple(r.value() for r in relevant)
                        +
                        (
                            (repr( command.location() ),)
                            if not section['headers'].get('name',None) else
                            (section['headers'].get('name'),)
                        )
                    ),
                    tuple(n.value() for n in new),
                ))
            
            for n in new:
                rewritten.append( n )
            
            break
            
        else:
            if G_SHOW_OPTIMIZATIONS:
                debug( '[fetch-rewrite-rule] no matching rewrite rule for %s' % repr( command ) )
            rewritten.append( command )
    
    if changed:
        return True, targetfn.rewriting_commands( rewritten )
    else:
        return False, targetfn

def optimize_propagate_localfn_constants( notes, recursive, opted, name, targetfn ):
    
    # we only propagate the locals here, we'll strip out unused sets in another step
    
    # rules:
    #   if a set is performed after a constant
    #   if we encounter a nonlocalsafe codeblock we have to forget the locals we are replacing
    #   
    #   until we reach another set
    #   
    
    addressed = set()
    replacements = {}
    
    rewritten = []
    changed = False
    for index, command in enumerate( targetfn.body().commands() ):
        
        if command.kind() == 'code':
            if '===' in command.value():
                sections = parse_code_sections( IMPLEMENTATION, command.value() )
                for section in sections:
                    if 'locals' in [ e.strip() for e in section['headers'].get('writes','').split(',') ]:
                        # locals are not safe in this code!
                        # kill our replacements cache
                        if G_SHOW_OPTIMIZATIONS:
                            debug('[propagate-localfn-constants] encountered code with "writes: locals", dropping replacements')
                        replacements = {}
                    else:
                        # locals are safe in this code!
                        # no need to drop replacements
                        if G_SHOW_OPTIMIZATIONS:
                            debug('[propagate-localfn-constants] assuming code without "writes: locals" doesn\'t' )
            else:
                # unstructured code can do anything
                # drop all local references
                if G_SHOW_OPTIMIZATIONS:
                    debug('[propagate-localfn-constants] encountered unstructured code, dropping replacements')
                replacements = {}
            rewritten.append( command )
            continue
        
        if command.kind() != 'localfn':
            rewritten.append( command )
            continue
        
        vv = command.value()
        if vv.startswith('$.'):
            rewritten.append( command )
            continue
        
        if not rewritten:
            rewritten.append( command )
            continue
        
        name, fn = vv.split('.',1)
        
        if fn == 'set':
            if rewritten[-1].kind() in ['integer', 'string']:
                replacements[ name ] = rewritten[-1]
            elif name in replacements:
                del replacements[ name ]
            rewritten.append( command )
            continue
        
        if fn == 'get':
            if name in replacements:
                log('[propagate-localfn-constants] replacing %s with constant %s' % (
                    repr( command ) ,
                    repr( replacements[ name ] ) ,
                ))
                changed = True
                rewritten.append( replacements[ name ] )
                continue
            else:
                rewritten.append( command )
                continue
        
        if fn == 'here':
            # we can do better than this
            # we can check what subset of locals are used until the associated name is .addr, .get or .jump'd
            # if we hit another <name>.here it's a new loop and we'd have to check that separately
            # for now, though, we'll just conservatively assume 'loop starts == dead locals'
            log('[propagate-localfn-constants] dropping all replacements on encountering potential loop start: %s' % repr( command ) )
            replacements = {}
            rewritten.append( command )
            continue
        
        if fn == 'addr':
            if name in replacements:
                del replacements[ name ]
            addressed.add( name )
            
        if fn == 'incr':
            if name in replacements:
                if replacements[ name ].kind() == 'integer':
                    log('[propagate-localfn-constants] incrementing constant local replacement: %s' % repr( command ) )
                    replacements[ name ] = Token(
                        location = replacements[ name ].location() ,
                        kind     = 'integer' ,
                        value    = replacements[ name ].value() + 1 ,
                    )
                    rewritten.append( command )
                    continue
                else:
                    del replacements[ name ]
                    rewritten.append( command )
                    continue
            else:
                rewritten.append( command )
                continue
        
        if fn == 'decr':
            if name in replacements:
                if replacements[ name ].kind() == 'integer':
                    log('[propagate-localfn-constants] decrementing constant local replacement: %s' % repr( command ) )
                    replacements[ name ] = Token(
                        location = replacements[ name ].location() ,
                        kind     = 'integer' ,
                        value    = replacements[ name ].value() - 1 ,
                    )
                    rewritten.append( command )
                    continue
                else:
                    del replacements[ name ]
                    rewritten.append( command )
                    continue
            else:
                rewritten.append( command )
                continue
        
        if fn == 'jump':
            rewritten.append( command )
            continue
        
        if fn == 'jumpIf':
            rewritten.append( command )
            continue
        
        raise Exception( '[propagate-localfn-constants] unknown localfn: %s' % repr( command ) )
    
    if changed:
        return True, targetfn.rewriting_commands( rewritten )
    else:
        return False, targetfn

class Uniques:
    def __init__(
        self ,
    ):
        self._next = 0
    
    def get( self ):
        v = self._next
        self._next += 1
        return v

# returnindex + 1
# newframe = stack + sizeof( returnframe = 16) * returnindex
# newframe[0] = fn_0
# newframe[1] = 0
# goto command

def generate_code(
    functions           ,
    usedFunctions       ,
    startname           ,
    trampolineSize      ,
    trampolineEndOffset ,
):
    stringCoalescer = StringCoalescer()
    
    staticStrings = set()
    
    pre  = []
    data = []
    code = []
    bss  = []
    
    uniques = Uniques()
    
    bss.append( 'section .bss\n' )
    bss.append( 'datastack: resq 1\n' )
    bss.append( 'callstack: resq 1\n' )
    bss.append( '\n' )
    
    data.append( 'section .data\n' )
    data.append( '\n' )
    
    code.append( 'section .text\n' )
    
    code.append( 'global _start\n')
    code.append( '\n')
    
    code.append( '; this trampoline is copied into the stack to enable closures\n' )
    code.append( '; it uses position independent instruction-pointer relative load effective address\n' )
    code.append( '; to find its jump return. it also ensures the return jump takes up the space we think it does\n' )
    code.append( '; we copy this into a stack frame for each closure the function references\n' )
    code.append( '; then, instead of passing the value of the closure, we pass this thing\n')
    code.append( '; when someone goes to call the closure, it calls this, which is in the stack of the binding callframe\n')
    code.append( '; this pushes its return address and jumps to the actual function to be called\n' )
    code.append( '; that function then resolves any parent locals relative to the return address, as they will follow the closures\n')
    code.append( '; this allows us to send a normal x64 points around, but one that is able to find its origin frame and locals!\n')
    code.append( '; this will make debugging hell and make any stack corruption a hundred times worse\n')
    code.append( '; it is perfect for kmforth\n')
    code.append( ' align 64\n')
    code.append( '_trampoline:\n')
    code.append( ' lea rax, [rel .trampoline_return]\n')
    code.append( ' mov [r15], rax\n')
    code.append( ' add r15, 8\n')
    code.append( ' mov rax, qword [rel .trampoline_target]\n')
    code.append( ' jmp rax\n' )
    code.append( ' align 8\n' )
    code.append( '.trampoline_return:\n')
    code.append( ' sub r15, 8\n' )
    code.append( ' jmp [r15]\n' )
    code.append( ' align 8\n' )
    code.append( '.trampoline_target:\n')
    code.append( '\n')
    code.append( '\n' )
    code.append( 'align 64\n')
    code.append( '_start:\n' )
    code.append( '    jmp %s\n' % startname )
    code.append( '\n')
    
    nn = 0
    for fn in functions:
        
        # 'tree shaking'
        if fn not in usedFunctions:
            continue
        
        code.append( '\n' )
        code.append( '; %s\n' % repr( functions[fn].location() ) )
        code.append( '  ' + fn + ':\n' )
        
        localfns = LocalFns(
            uniques             = uniques             ,
            functions           = functions           ,
            fn                  = fn                  ,
            trampolineSize      = trampolineSize      ,
            trampolineEndOffset = trampolineEndOffset ,
        )
        
        frameOffsets = functions[ fn ].body().frame_offsets(
            functions           = functions           ,
            trampolineSize      = trampolineSize      ,
            trampolineEndOffset = trampolineEndOffset ,
        )
        
        if frameOffsets.frame_total_size():
            code.append( '  ; make space for any closure trampolines and locals\n' )
            code.append( '  add r15, %d\n' % ( frameOffsets.frame_total_size() ) )

        if trampolineSize != 32:
            raise Exception( 'need to make this general' )
        
        for closureName in frameOffsets.nonlocalvar_names():
            code.append( ' ; copy the trampoline code into the stack\n' )
            code.append( '  mov rax, [_trampoline]\n' )
            code.append( '  mov qword [r15-8*%d], rax\n' % (
                frameOffsets.nonlocalvar_trampoline_slotno( closureName ),
            ))
            code.append( '  mov rax, [_trampoline+8]\n' )
            code.append( '  mov qword [r15-8*%d+8], rax\n' % (
                frameOffsets.nonlocalvar_trampoline_slotno( closureName ),
            ))
            code.append( '  mov rax, [_trampoline+16]\n' )
            code.append( '  mov qword [r15-8*%d+16], rax\n' % (
                frameOffsets.nonlocalvar_trampoline_slotno( closureName ),
            ))
            code.append( '  mov rax, [_trampoline+24]\n' )
            code.append( '  mov qword [r15-8*%d+24], rax\n' % (
                frameOffsets.nonlocalvar_trampoline_slotno( closureName ),
            ))
            code.append( ' ; and the trampoline target right after it\n' )
            code.append( '  mov qword [r15-8*%d], %s\n' % (
                frameOffsets.nonlocalvar_target_slotno( closureName ),
                closureName
            ))
        
        for command in functions[ fn ].body().commands():
            
            if command.kind() == 'word':
                rt = '.' + fn + '_' + str( nn )
                nn = nn + 1
                
                code.append( '    ; calling %s\n' % command.value() )
                code.append( '    mov qword [r15], %s\n' % rt )
                code.append( '    add r15, 8\n' )
                code.append( '    jmp ' + command.value() + '\n' )
                code.append( '  %s:\n' % rt )
                
            elif command.kind() == 'code':
                code.append( '\n' )
                code.append( '; including code literal\n' )
                code.append( fetch_code(
                    impl = IMPLEMENTATION ,
                    data = command.value() ,
                ))
                code.append( '\n' )
                
            elif command.kind() == 'string':
                
                sn = stringCoalescer.lookup( command.value() )
                if not sn:
                    sn = "km_c_" + str(uniques.get())
                    data.append( '  ' + sn + ':\n' )
                    # convert \n into 10 here ( 10, 13 for windows, but fuck those guys
                    data.append( "    db %s\n" % asm_stringize( command.value() ) )
                    stringCoalescer.remember( command.value(), sn )
                    
                code.append( '   ; pushing string literal %s\n' % repr( command.value() ) )
                code.append( '   mov qword [r14], %s\n' % sn )
                code.append( '   add r14, 8\n' )
                
            elif command.kind() == 'integer':
                # 
                # you can't write an immediate larger than a 32bit value directly to memory
                # you have to load the value into a register and use the register command form
                # 
                if command.value() > (4294967296 - 1):
                    code.append( '   ; push integer > 32bit\n' )
                    code.append( '   mov rax, %s\n' % command.value() )
                    code.append( '   mov [r14],rax\n' )
                    code.append( '   add r14,8\n' )
                else:
                    code.append( '   ; push integer < 32bit\n' )
                    code.append( '   mov qword [r14], %s\n' % command.value() )
                    code.append( '   add r14, 8\n' )
            
            # user code can't create a FORWARDJUMPIF, but optimization passes can
            elif command.kind() == 'FORWARDJUMPIF':
                code.append( INLINED_LEAVEIF % { 'endlabel' : command.value() } )
                
            # user code can't create a JUMPTARGET, but optimization passes can
            elif command.kind() == 'JUMPTARGET':
                code.append( command.value() + ":\n" )
            
            elif command.kind() == 'localfn':
                if command.value().startswith('$.'):
                    builtin = command.value()
                    # no localfn for unconditional call, just use 'call'
                    if builtin == '$.callIf':
                        localfns.implementation_callIf( code )
                    elif builtin == '$.jumpIf':
                        localfns.implementation_jumpIf( code )
                    elif builtin == '$.jump':
                        localfns.implementation_jump( code )
                    elif builtin == '$.leaveIf':
                        localfns.implementation_leaveIf( code )
                    elif builtin == '$.call':
                        localfns.implementation_call( code )
                    elif builtin == '$.noopt':
                        # this just prevents inlining the function or inlining into the function
                        pass
                    else:
                        raise Exception( 'unknown builtin localfn: %s' % repr( command.value() ) )
                else:
                    # locals getters and setters
                    commandBits = command.value().split('.',1)
                    if len( commandBits ) != 2:
                        raise Exception( 'command-bits length not 2? %s' % repr( commandBits ) )
                    localName, memberfn = commandBits
                    
                    localvar = localfns.localvar( localName )
                    
                    if memberfn == 'get':
                        localvar.implementation_get( code )
                    elif memberfn == 'set':
                        localvar.implementation_set( code )
                    elif memberfn == 'update':
                        localvar.implementation_update( code )
                    elif memberfn == 'call':
                        localvar.implementation_call( code )
                    elif memberfn == 'copy':
                        localvar.implementation_copy( code )
                    elif memberfn == 'here':
                        localvar.implementation_here( code )
                    elif memberfn == 'jump':
                        localvar.implementation_jump( code )
                    elif memberfn == 'jumpIf':
                        localvar.implementation_jumpIf( code )
                    elif memberfn == 'addr':
                        localvar.implementation_addr( code )
                    elif memberfn == 'incr':
                        localvar.implementation_incr( code )
                    elif memberfn == 'decr':
                        localvar.implementation_decr( code )
                    else:
                        raise Exception( 'unknown localfn ( expecting <local>.get or <local>.set ): %s' % repr( command.value() ) )
                    
            elif command.kind() == 'fnref':
                code.append( '    ; push reference to fn\n' )
                code.append( '    mov qword [r14], %s\n' % command.value() )
                code.append( '    add r14, 8\n' )
                
            elif command.kind() == 'subfn':
                if functions[ command.value() ].is_closure( functions ):
                    # needs a trampoline for nonlocal access
                    code.append( ' ; for subfn, push closure (%s) trampoline reference\n' % repr( command.value() ))
                    code.append( ' lea rax, [r15+8*%d]\n' % (- frameOffsets.nonlocalvar_trampoline_slotno( command.value())))
                    code.append( ' mov qword [r14], rax\n' )
                    code.append( ' add r14, 8\n' )
                else:
                    # normal c-style function pointer
                    code.append( '    ; push subfn reference\n' )
                    code.append( '    mov qword [r14], %s\n' % command.value() )
                    code.append( '    add r14, 8\n' )
            else:
                raise Exception( 'wat %s %s' % ( str( command.kind() ), repr( command.value() ) ) )
        
        if frameOffsets.frame_total_size():
            code.append( '    ; pop any trampolines and locals\n' )
            code.append( '    sub r15, %d\n' % ( frameOffsets.frame_total_size() ) )
            
        code.append( '    ; pop and jump to caller\n' )
        code.append( '    sub r15, 8\n' )
        code.append( '    jmp [r15]\n' )
        
    return '\n'.join( [''.join(pre), ''.join( data ), ''.join( code ), ''.join( bss ) ] )
    
    
class LocalFns:
    def __init__(
        self                ,
        uniques             ,
        functions           ,
        fn                  ,
        trampolineSize      ,
        trampolineEndOffset ,
    ):
        self._uniques             = uniques
        self._functions           = functions
        self._fn                  = fn
        self._trampolineSize      = trampolineSize
        self._trampolineEndOffset = trampolineEndOffset
        
        self._frameOffsets = functions[ fn ].body().frame_offsets(
            functions           = functions           ,
            trampolineSize      = trampolineSize      ,
            trampolineEndOffset = trampolineEndOffset ,
        )
        
        self._body = functions[ fn ].body()
        return
    
    def localvar( self, localVarName ):
        return LocalVarFns(
            uniques             = self._uniques             ,
            functions           = self._functions           ,
            fn                  = self._fn                  ,
            localVarName        = localVarName              ,
            frameOffsets        = self._frameOffsets        ,
            trampolineSize      = self._trampolineSize      ,
            trampolineEndOffset = self._trampolineEndOffset ,
        )
    
    def implementation_callIf( self, code ):
        label = '.km_nocall_' + str(self._uniques.get())
        code.append( '    ; callIf localfn\n' )
        code.append( '    sub r14, 8\n' )                  # pop todo
        code.append( '    mov rax, [r14]\n' )
        code.append( '    sub r14, 8\n' )                  # pop cond
        code.append( '    mov rbx, [r14]\n' )
        code.append( '    test rbx,rbx\n' )                # test setting zf
        code.append( '    jz %s\n' % label )               # jump over call if 0
        code.append( '    mov qword [r15], %s\n' % label ) # push return label onto callstack
        code.append( '    add r15, 8\n' )
        code.append( '    jmp rax\n' )                     # go
        code.append( '   %s:\n' % label )                  # return label
        
    def implementation_jumpIf( self, code ):
        label = '.km_nojump_' + str(self._uniques.get())
        code.append( '    ; jumpIf \n' )
        code.append( '    sub r14, 8\n' )     # pop jump target
        code.append( '    mov rax, [r14]\n' )
        code.append( '    sub r14, 8\n' )     # pop cond
        code.append( '    mov rbx, [r14]\n' )
        code.append( '    test rbx,rbx\n' )   # test cond
        code.append( '    jz %s\n' % label )  # jump over jump if 0
        code.append( '    jmp rax\n' )        # jump
        code.append( '   %s:\n' % label )     # don't
        
    def implementation_jump( self, code ):
        code.append( '    ; jump\n' )
        code.append( '    sub r14, 8\n' )
        code.append( '    jmp [r14]\n' )
        
    def implementation_leaveIf( self, code ):
        label = '.km_noleave_' + str(self._uniques.get())
        code.append( '    ; leaveIf\n' )
        code.append( '    sub r14, 8\n' )
        code.append( '    mov rax, [r14]\n' )
        code.append( '    test rax,rax\n' )
        code.append( '    jz %s\n' % label )
        if self._frameOffsets.frame_total_size():
            code.append( '    ; (popping locals before leaving)\n' )
            code.append( '    sub r15, %d\n' % ( self._frameOffsets.frame_total_size() ) )
        code.append( '    sub r15, 8\n' )
        code.append( '    jmp [r15]\n' )
        code.append( '   %s:\n' % label )
        
    def implementation_call( self, code ):
        label = '.km_return_'+  str(self._uniques.get())
        code.append( '    ; $.call\n' )
        code.append( '    mov qword [r15], %s\n' % label )
        code.append( '    add r15, 8\n' )
        code.append( '    sub r14, 8\n' )
        code.append( '    jmp [r14]\n' )
        code.append( label + ':\n' )
        

# we don't need to care what the parent is in the code, just how many indirections
# are required to get to a certain variable. we will then need to make usage of that
# variable perform the correct number of parent hops and get/set/addr the local in
# the resulting frame.
# we always know the number of hops for a given variable, because a closer is only
# created by having them inside other functions or closures
# 
class LocalVarFns:
    def __init__(
        self                ,
        uniques             ,
        functions           ,
        fn                  ,
        localVarName        ,
        frameOffsets        ,
        trampolineSize      ,
        trampolineEndOffset ,
    ):
        self._uniques             = uniques
        self._functions           = functions
        self._fn                  = fn
        self._localVarName        = localVarName
        self._frameOffsets        = frameOffsets
        self._trampolineSize      = trampolineSize
        self._trampolineEndOffset = trampolineEndOffset
        
        self._slotno, self._indirections = self._determine_slotno_and_indirections(
            trampolineSize      = trampolineSize      ,
            trampolineEndOffset = trampolineEndOffset ,
        )
        
        return
    
    def _determine_slotno_and_indirections(
        self                ,
        trampolineSize      ,
        trampolineEndOffset ,
    ):
        indirections = []
        cfn = self._fn
        while True:
            frameOffsets = self._functions[ cfn ].body().frame_offsets(
                functions           = self._functions     ,
                trampolineSize      = trampolineSize      ,
                trampolineEndOffset = trampolineEndOffset ,
            )
            slotno = frameOffsets.localvar_slotno( self._localVarName )
            if slotno != None:
                break
            
            cfn = self._functions[ cfn ].parent()
            indirections.append( cfn )
            
            if cfn != None:
                continue
            else:
                raise Exception( 'cannot locate localvar named (%s) in function (%s)' % (
                    repr(self._localVarName),
                    repr(self._fn),
                ))
        return slotno, indirections
    
    def _walk_to_target_frame( self, code ):
        code.append( ' ; walking trampoline\n' )
        code.append( ' ; get return-address\n' )
        # the return address is one slot past the end of the frame
        code.append( ' mov rax, [r15+8*%d+8*%d]\n' % (
            - self._frameOffsets.frame_slots_used(),
            - 1
        ))
        remaining = list( self._indirections )
        last = remaining.pop()
        penultimate = self._fn
        for cfn in remaining:
            parentFrameOffsets = self._functions[ cfn ].body().frame_offsets(
                functions           = self._functions           ,
                trampolineSize      = self._trampolineSize      ,
                trampolineEndOffset = self._trampolineEndOffset ,
            )
            code.append( ' ; get next return-address\n' )
            code.append( ' mov rax, [rax+8*%d+8*%d+8*%d+8*%d+8*%d]\n' % (
                + (self._trampolineEndOffset // 8),
                - (self._trampolineSize // 8),
                + parentFrameOffsets.nonlocalvar_trampoline_slotno( penultimate ),
                - parentFrameOffsets.frame_slots_used(),
                - 1,
            ))
            penultimate = cfn
        lastFrameOffsets = self._functions[ last ].body().frame_offsets(
            functions           = self._functions           ,
            trampolineSize      = self._trampolineSize      ,
            trampolineEndOffset = self._trampolineEndOffset ,
        )
        return last, lastFrameOffsets, '[rax+8*%d+8*%d+8*%d+8*%d]' % (
                + (self._trampolineEndOffset // 8),
                - (self._trampolineSize // 8),
                + lastFrameOffsets.nonlocalvar_trampoline_slotno( penultimate ),
                - lastFrameOffsets.localvar_slotno( self._localVarName ),
        )

    def _require_slot_sized( self, getSizeFn, name ):
        if getSizeFn( name ) != 8:
            a = 'you can only .get, .set, .update, .call and .here vars of size 8. other sizes only offer .addr, '
            b = 'found %s in %s which is size %s' % (
                repr( name ),
                repr( unmangle( self._fn ) ),
                repr( getSizeFn( name ) ) ,
            )
            raise Exception( a + b )
    
    def implementation_get( self, code ):
        if self._indirections:
            parent, parentOffsets, addr = self._walk_to_target_frame( code )
            self._require_slot_sized( parentOffsets.localvar_size, self._localVarName )
            code.append( '   ; push nonlocal (%s) to datastack\n' % repr( self._localVarName ) )
            code.append( '   mov rax, %s\n' % addr )
            code.append( '   mov qword [r14], rax\n' )
            code.append( '   add r14, 8\n' )
            return
        else:
            self._require_slot_sized( self._frameOffsets.localvar_size, self._localVarName )
            code.append( '    ; push local (%s) to datastack\n' % repr( self._localVarName ) )
            code.append( '    mov rax, [r15-8*%d]\n' % (self._slotno) )
            code.append( '    mov qword [r14], rax\n' )
            code.append( '    add r14, 8\n' )
        
    def implementation_set( self, code ):
        if self._indirections:
            parent, parentOffsets, addr = self._walk_to_target_frame( code )
            self._require_slot_sized( parentOffsets.localvar_size, self._localVarName )
            code.append( '    ; pop datastack storing to nonlocal (%s)\n' % repr( self._localVarName ))
            code.append( '    sub r14, 8\n')
            code.append( '    mov rbx, [r14]\n' )
            code.append( '    mov qword %s, rbx\n' % addr )
        else:
            self._require_slot_sized( self._frameOffsets.localvar_size, self._localVarName )
            code.append( '    ; pop datastack storing to local (%s)\n' % ( repr( self._localVarName ) ) )
            code.append( '    sub r14, 8\n' )
            code.append( '    mov rax, [r14]\n' )
            code.append( '    mov qword [r15-8*%d], rax\n' % (self._slotno) )
            
    def implementation_update( self, code ):
        if self._indirections:
            parent, parentOffsets, addr = self._walk_to_target_frame( code )
            self._require_slot_sized( parentOffsets.localvar_size, self._localVarName )
            label = '.km_update_nonlocal_' + str(self._uniques.get())
            code.append('    ; update value of nonlocal %s by getting, invoking and setting\n' % repr( self._localVarName ))
            code.append('    mov rbx, [r14-8]\n')
            code.append('    mov rax, %s\n' % addr)
            code.append('    mov [r14-8], rax\n')
            code.append('    mov qword [r15], %s\n' % label)
            code.append('    add r15, 8\n')
            code.append('    jmp rbx\n')
            code.append(' %s:\n' % label)
            # recalculate addr because we don't have anywhere to save it and registers aren't save across calls
            parent, parentOffsets, addr = self._walk_to_target_frame( code )
            code.append('    mov rbx, [r14-8]\n')
            code.append('    sub r14, 8\n')
            code.append('    mov qword %s, rbx\n' % addr)
            code.append('    ; end non-local update\n')
        else:
            self._require_slot_sized( self._frameOffsets.localvar_size, self._localVarName )
            label = '.km_update_local_' + str(self._uniques.get())
            code.append('    ; update value of local %s by getting, invoking and setting\n' % repr( self._localVarName ))
            code.append('    mov rbx, [r14-8]\n')
            code.append('    mov rax, [r15+8*%d]\n' % (- self._slotno))
            code.append('    mov qword [r14-8], rax\n')
            code.append('    mov qword [r15], %s\n' % label)
            code.append('    add r15, 8\n')
            code.append('    jmp rbx\n')
            code.append(' %s:\n' % label)
            code.append('    mov rax, [r14-8]\n')
            code.append('    sub r14, 8\n')
            code.append('    mov qword [r15+8*%d], rax\n' % (- self._slotno))
            code.append('    ; end local update\n')
    
    def implementation_call( self, code ):
        if self._indirections:
            parent, parentOffsets, addr = self._walk_to_target_frame( code )
            self._require_slot_sized( parentOffsets.localvar_size, self._localVarName )
            label = '.km_call_nonlocal_' + str(self._uniques.get())
            code.append( '    mov qword [r15], %s\n' % label )
            code.append( '    add r15, 8\n' )
            code.append( '    jmp %s\n' % addr )
            code.append( ' %s:\n' % label )
        else:
            label = '.km_call_local_' + str(self._uniques.get())
            code.append( '    mov rbx, [r15+8*%d]\n' % (- self._slotno))
            code.append( '    mov qword [r15], %s\n' % label )
            code.append( '    add r15, 8\n' )
            code.append( '    jmp rbx\n' )
            code.append( ' %s:\n' % label )
    
    def implementation_copy( self, code ):
        if self._indirections:
            parent, parentOffsets, addr = self._walk_to_target_frame( code )
            self._require_slot_sized( parentOffsets.localvar_size, self._localVarName )
            code.append( '    ; copy top of datastack to nonlocal (%s)\n' % ( repr( self._localVarName ) ) )
            code.append( '    mov rbx, [r14-8]\n' )
            code.append( '    mov qword %s, rbx\n' % addr )
        else:
            self._require_slot_sized( self._frameOffsets.localvar_size, self._localVarName )
            code.append( '    ; copy datastack to local (%s)\n' % ( repr( self._localVarName ) ) )
            code.append( '    mov rax, [r14-8]\n' )
            code.append( '    mov qword [r15-8*%d], rax\n' % (self._slotno) )
    
    def implementation_here( self, code ):
        if self._indirections:
            # 
            # there is no reasonable reason to ever store a nonlocal here
            # I'll allow it
            #
            parent, parentOffsets, addr = self._walk_to_target_frame( code )
            self._require_slot_sized( self._parentOffsets.localvar_size, self._localVarName )
            label = '.km_here_nonlocal_' + str(self._uniques.get())
            code.append( '    ; set local (%s) to label following this command\n' % repr(self._localVarName) )
            code.append( '    mov qword %s, %s\n' % (addr, label))
            code.append( '    %s:\n' % label )
        else:
            self._require_slot_sized( self._frameOffsets.localvar_size, self._localVarName )
            label = '.km_here_' + str(self._uniques.get())
            code.append( '    ; set local (%s) to label following this command\n' % repr(self._localVarName))
            code.append( '    mov qword [r15-8*%d], %s\n' % ( (self._slotno), label) )
            code.append( '    %s:\n' % label )
        
    def implementation_jump( self, code ):
        if self._indirections:
            parent, parentOffsets, addr = self._walk_to_target_frame( code )
            self._require_slot_sized( parentOffsets.localvar_size, self._localVarName )
            code.append( '    jump %s\n' % addr )
        else:
            self._require_slot_sized( self._frameOffsets.localvar_size, self._localVarName )
            code.append( '    jmp qword [r15+8*%d]\n' % (- self._slotno) )
        
    def implementation_jumpIf( self, code ):
        if self._indirections:
            label = '.km_dont_jumpif_nonlocal_' + str(self._uniques.get())
            code.append( '    sub r14,8\n' )
            code.append( '    mov rbx,[r14]\n' )
            code.append( '    test rbx,rbx\n' )
            code.append( '    jz %s\n' % label )
            parent, parentOffsets, addr = self._walk_to_target_frame( code )
            self._require_slot_sized( parentOffsets.loclvar_size, self._localVarName )
            code.append( '    jmp %s\n' % addr )
            code.append( '%s:\n' % label )
        else:
            self._require_slot_sized( self._frameOffsets.localvar_size, self._localVarName )
            label = '.km_dont_jumpif_' + str(self._uniques.get())
            code.append( '    sub r14,8\n' )
            code.append( '    mov rax,[r14]\n' )
            code.append( '    test rax,rax\n' )
            code.append( '    jz %s\n' % label )
            code.append( '    jmp [r15-8*%d]\n' % (self._slotno) )
            code.append( '%s:\n' % label )

    def implementation_addr( self, code ):
        if self._indirections:
            parent, parentOffsets, addr = self._walk_to_target_frame( code )
            code.append( '    ; push address of nonlocal (%s) onto stack\n' % repr( self._localVarName ) )
            code.append( '    lea rax, %s\n' % addr )
            code.append( '    mov [r14],rax\n' )
            code.append( '    add r14,8\n' )
        else:
            code.append( '    ; push address of local (%s) onto stack\n' % repr( self._localVarName ) )
            code.append( '    lea  rax,[r15-8*%d]\n' % (self._slotno) )
            code.append( '    mov  [r14],rax\n' )
            code.append( '    add  r14,8\n' )
        
    def implementation_incr( self, code ):
        if self._indirections:
            parent, parentOffsets, addr = self._walk_to_target_frame( code )
            self._require_slot_sized( parentOffsets.localvar_size, self._localVarName )
            code.append( '    ; incr nonlocal (%s) in-place\n' % repr( self._localVarName ) )
            code.append( '    inc qword %s\n' % addr )
        else:
            self._require_slot_sized( self._frameOffsets.localvar_size, self._localVarName )
            code.append( '    ; incr local (%s) in-place\n' % repr( self._localVarName ) )
            code.append( '    inc qword [r15-8*%d]\n' % (self._slotno) )

    def implementation_decr( self, code ):
        if self._indirections:
            parent, parentOffsets, addr = self._walk_to_target_frame( code )
            self._require_slot_sized( parentOffsets.localvar_size, self._localVarName )
            code.append( '    ; decr nonlocal (%s) in-place\n' % repr( self._localVarName ) )
            code.append( '    dec qword %s\n' % addr )
        else:
            self._require_slot_sized( self._frameOffsets.localvar_size, self._localVarName )
            code.append( '    ; incr local (%s) in-place\n' % repr( self._localVarName ) )
            code.append( '    dec qword [r15-8*%d]\n' % (self._slotno) )
    
def asm_stringize( ss ):
    bits      = []
    instr     = False
    for cc in ss:
        if cc.lower() in ' abcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()[]{}|,:':
            if instr:
                bits.append( cc )
                continue
            else:
                if bits:
                    bits.append( ',' )
                bits.append( "'" )
                bits.append( cc )
                instr = True
        else:
            if instr:
                bits.append( "'")
                instr = False
            first = None
            for bit in cc.encode('utf-8').hex():
                if first == None:
                    first = bit
                else:
                    if bits:
                        bits.append( ',' )
                    bits.append( '0x' + first + bit )
                    first = None
    if instr:
        bits.append( "'" )
    
    if bits:
        bits.append(',')
    
    bits.append( '0' )
    
    return ''.join( bits )

def fetch_code( impl, data ):
    if '===' not in data:
        return data
    
    for section in parse_code_sections( impl, data ):
        
        if not (section['headers'].get('impl', impl) == impl):
            if G_SHOW_OPTIMIZATIONS:
                debug( '[fetch-code] skipping section, wrong impl: %s' % repr( section ) )
            continue
        
        if not (section['headers'].get('type','code') == 'code'):
            if G_SHOW_OPTIMIZATIONS:
                debug( '[fetch-code] skipping section, wrong type: %s' % repr( section ) )
            continue
        
        if not (section['headers'].get('when', '').strip() == ''):
            if G_SHOW_OPTIMIZATIONS:
                debug( '[fetch-code] skipping section, has conditional: %s' % repr( section ) )
            continue
        
        return section['body']
    
    raise Exception( 'no appropriate code section found: %s' % repr( data ) )
    
def parse_code_sections( impl, data ):
    lines = Source( data.strip().split('\n') )
    
    done = False
    sections = []
    while True:
        headers = {}
        while True:
            line = lines.take()
            if line == None:
                done = True
                break
            elif '===' in line:
                raise Exception( 'cannot have === in headers section, separate headers by at least one blank line, in %s' % (
                    repr( data ) ,
                ))
            elif line.strip() == "":
                break
            else:
                name, value = line.strip().split(':',1)
                name = name.strip()
                value = value.strip()
                headers[ name ] = value
        
        if done:
            break
        
        body = []
        while True:
            line = lines.take()
            if line == None:
                done = True
                break
            elif '===' in line:
                break
            else:
                body.append( line )
        
        sections.append({'headers' : headers, 'body' : '\n'.join(body) + '\n'})
        
        if done:
            break
    
    return sections

def unparse_code_sections( sections ):
    bits = []
    
    for section in sections:
        for header in section['headers'].items():
            bits.append( '%s : %s' % ( header[0], header[1] ) )
        
        bits.append( '' )
        
        bits.append( section['body'] )
        
        bits.append( '===' )
    
    return '\n'.join( bits[:-1] )

#####

if __name__ == '__main__':
    main()
