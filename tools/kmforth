#!/usr/bin/env python3

# everything is a lot easier if I give my callstack a little bit of state

# how to set gdb to step through assembly
# https://stackoverflow.com/questions/2420813/using-gdb-to-single-step-assembly-code-outside-specified-executable-causes-error

import sys
import os
import contextlib
import re

from modules.options             import parse_options
from modules.scanner             import Scanner
from modules.filesource          import FileSource
from modules.source              import Source
from modules.token               import Token
from modules.compilation_manager import CompilationManager
from modules.uniques             import Uniques
from modules.context             import Context
from modules.parser              import Parser
from modules.mangling            import mangle, unmangle

import modules.constants as constants


IMPLEMENTATION = 'kmforth/python'

G_SHOW_EXPANSIONS = False
G_EXPANSION_ID = [0]
G_SHOW_OPTIMIZATIONS = False
G_DEBUG_OPTIMIZATIONS = False
G_INLINE_THRESHOLD = 10
G_INLINE_ONLY = None
G_INLINE_EXCEPT = None

def debug( *args, **kwargs ):
    if G_DEBUG_OPTIMIZATIONS:
        kwargs['file'] = sys.stderr
        print( *args, **kwargs )

def log( *args, **kwargs ):
    kwargs[ 'file' ] = sys.stderr
    print( *args, **kwargs )

def main():
    options, err = parse_options(sys.argv)
    if err:
        panic(err)
    
    if options.showExpansions:
        global G_SHOW_EXPANSIONS
        G_SHOW_EXPANSIONS = True
    
    if options.showOptimizations:
        global G_SHOW_OPTIMIZATIONS
        G_SHOW_OPTIMIZATIONS = True
        
    if options.debugOptimizations:
        global G_DEBUG_OPTIMIZATIONS
        G_DEBUG_OPTIMIZATIONS = True
        
    if options.inlineOnly:
        global G_INLINE_ONLY
        pattern = '.*(' + options.inlineOnly + ').*'
        if G_SHOW_OPTIMIZATIONS:
            log('[options] --inline-only pattern is %s' % repr( pattern ))
        G_INLINE_ONLY = re.compile( pattern )
    
    if options.inlineExcept:
        global G_INLINE_EXCEPT
        pattern = '.*(' + options.inlineExcept + ').*'
        if G_SHOW_OPTIMIZATIONS:
            log('[options] --inline-except pattern is %s' % repr( pattern ))
        G_INLINE_EXCEPT = re.compile( pattern )
    
    context = Context(
        log = log,
    )
    
    parser = Parser(
        options = options ,
        context = context ,
    )
    
    compilationManager = CompilationManager(
        options = options ,
        context = context ,
        parser  = parser  ,
    )
    
    fns, usedFns = compilationManager.compile_program(
        options    = options                                                            ,
        targetPath = os.path.normpath( os.path.join( os.getcwd(), options.targetPath )) ,
    )
    
    code = generate_code(
        functions           = fns                              ,
        usedFunctions       = usedFns                          ,
        startname           = options.startname                ,
        trampolineSize      = int(options.trampolineSize)      ,
        trampolineEndOffset = int(options.trampolineEndOffset) ,
    )
    
    print(code)

#####

class NamedNonArgSource:
    def __init__(
        self     ,
        namer    ,
        expander ,
    ):
        self._namer    = namer
        self._expander = expander
        return
    
    def namer(
        self ,
    ):
        return self._namer
    
    def variations(
        self ,
    ):
        return self._expander.non_argument_consuming_variations()

#####

#####

class StringCoalescer:
    def __init__(
        self ,
    ):
        self._string2label = {}
        return
    
    def lookup( self, ss ):
        return self._string2label.get( ss, None )
        
    def remember( self, ss, label ):
        self._string2label[ ss ] = label


#####

# possible opts
# 
# constant propagation:
#   if a function just produces a constant, replace it with that constant in the caller
# function inlining:
#   if a function doesn't recurse
#   and is under some threshold for number of commands used in the callee
#   inline its locals and commands into the calling function
# branch pruning
#   if a conditional call would work against a constant, replace it with the call or a pop
# unused local/constant pruning
#   if a local or constant isn't used, don't bother to set it
# call pruning
#   if a function is side effect free and its value isn't used, don't bother to call it
# return elision:
#   if a function does not have any locals
#   tail call to the last function called in that function
#   flattens the return stack avoid unnecessary return chains
# assembly register and constant alternatives
#   a syntax for annotating assembly segments with short code segments
#   that can be used for replacing it with alternate code or constants
#   where appropriate

# immediately triggering the other function to run is dumb
# it makes writing simple loops a pain
# it should still wait for the next, just with a value set to return
# otherwise it makes writing logic for it unnecessarily hairy
# 
class NotStupidCoroutine:
    def __init__(
        self   ,
        actual ,
    ):
        self._actual  = iter(actual)
        self._pending = ()
    
    def __iter__( self ):
        return self
    
    def __next__( self ):
        if self._pending:
            p = self._pending[0]
            self._pending = None
            return self._actual.send(p)
        else:
            return next(self._actual)
    
    def prepare_send( self, value ):
        if self._pending:
            raise Exception( 'cannot stage yield-expression value when already set' )
        else:
            self._pending = (value,)

# fixing optimization is going to be a slog of ensuring that functions that are inlined
# have their parentage appropriately rewritten so that their trampolines continue working

def optimize( allfns, used, callgraph, startname, uniques ):
    notes = {}
    opted = {}
    
    recursive = set()
    
    callees = callgraph
    callers = {}
    for (k,vv) in callees.items():
        for v in vv:
            if v not in callers:
                callers[v] = set()
            callers[v].add(k)
    
    pending = [(startname, NotStupidCoroutine(optimize_fn(
        notes     = notes             ,
        callees   = callees           ,
        callers   = callers           ,
        opted     = opted             ,
        allfns    = allfns            ,
        recursive = recursive         ,
        name      = startname         ,
        fn        = allfns[startname] ,
        uniques   = uniques           ,
    )))]
    
    pendingNames = { startname }
    
    while pending:
        name, optgn = pending[-1]
        needed = next( optgn, None )
        if needed == None:
            pendingNames.remove(pending[-1][0])
            pending.pop()
            if pending:
                pending[-1][1].prepare_send(False)
        elif needed in opted:
            pending[-1][1].prepare_send(False)
        elif needed in pendingNames:
            pending[-1][1].prepare_send(True)
        else:
            pending.append( (needed,NotStupidCoroutine(optimize_fn(
                notes     = notes          ,
                callees   = callees        ,
                callers   = callers        ,
                opted     = opted          ,
                allfns    = allfns         ,
                recursive = recursive      ,
                name      = needed         ,
                fn        = allfns[needed] ,
                uniques   = uniques        ,
            ))))
            pendingNames.add( needed )
    
    return opted

def optimize_fn( notes, callees, callers, opted, allfns, recursive, name, fn, uniques ):
    
    for command in fn.body().commands():
        
        if command.kind() == 'word':
            if (yield command.value()):
                recursive.add( command.value() )
        elif command.kind() == 'subfn':
            subfns = [command.value()]
            while subfns:
                subfn = subfns.pop()
                if (yield subfn):
                    recursive.add( command.value() )
                else:
                    for subsubfn in opted[subfn].body().commands():
                        if subsubfn.kind() == 'subfn':
                            subfns.append(subsubfn.value())
        
        elif command.kind() == 'localfn':
            pass
        elif command.kind() == 'integer':
            pass
        elif command.kind() == 'code':
            pass
        elif command.kind() == 'string':
            pass
        elif command.kind() == 'fnref':
            if (yield command.value()):
                recursive.add( command.value() )
        elif command.kind() == 'FORWARDJUMPIF':
            pass
        elif command.kind() == 'JUMPTARGET':
            pass
        else:
            raise Exception( 'unknown kind: %s' % repr( command.kind() ) )
    
    changed   = False
    updatedfn = fn
    while True:
        for optimizefn in [
            optimize_inline_nonrecursive,
            optimize_perform_token_replacements,
            optimize_propagate_localfn_constants,
        ]:
            changed, updatedfn, newclosures = optimizefn(
                notes     = notes     ,
                recursive = recursive ,
                opted     = opted     ,
                name      = name      ,
                targetfn  = updatedfn ,
                uniques   = uniques   ,
            )
            
            for closure in newclosures:
                allfns[closure.name().value()] = closure
            
            for closure in newclosures:
                if (yield closure.name().value()):
                    recursive.add(closure.name().value())
            
        if changed:
            continue
        else:
            break
    
    opted[ name ] = updatedfn
    
    yield None

INLINED_LEAVEIF = '''
    ; inlined leaveIf (--> jumpForward)
    sub r14, 8
    mov rax, [r14]
    test rax,rax
    jnz %(endlabel)s
'''

def optimize_inline_nonrecursive( notes, recursive, opted, name, targetfn, uniques ):
    
    rewritten = []
    newlocals = []
    newclosures = {} # old -> new
    
    changed = False
    
    for localvar in targetfn.body().localvars():
        newlocals.append( localvar )
    
    for command in targetfn.body().commands():
        
        if command.kind() == 'localfn' and command.value() == '$.noopt':
            if G_SHOW_OPTIMIZATIONS:
                debug('[inline-nonrecursive] refusing to optimize due to $.noopt in %s' % repr( unmangle( name ) ) )
            changed = False
            break
        
        if command.kind() == 'word':
            vv = command.value()
            isRecursive = vv in recursive
            hasCodeTouchingTheCallStack = (
                vv in opted and any(
                    (e.kind() == 'code' and 'r15' in e.value())
                    for e in opted[vv].body().commands()
                )
            )
            
            if isRecursive:
                if G_SHOW_OPTIMIZATIONS:
                    debug('[inline-nonrecursive] refusing to inline %s into %s because it is recursive' % (
                        repr( unmangle( vv ) ) ,
                        repr( unmangle( name ) ) ,
                    ))
                rewritten.append( command )
            elif hasCodeTouchingTheCallStack:
                # no optimization for you
                if G_SHOW_OPTIMIZATIONS:
                    debug('[inline-nonrecursive] refusing to inline into %s due to use of r15 in assembly in %s' % (
                        repr( unmangle( name ) ) ,
                        repr( unmangle( vv ) ) ,
                    ))
                rewritten.append( command )
            else:
                if G_INLINE_ONLY:
                    m = G_INLINE_ONLY.match(unmangle( vv ))
                    if not m:
                        if G_SHOW_OPTIMIZATIONS:
                            debug('[inline-nonrecursive] refusing to inline %s, does not match --inline-only regex' % (
                                repr( unmangle( vv ) ),
                            ))
                        rewritten.append( command )
                        continue
                
                if G_INLINE_EXCEPT:
                    m = G_INLINE_EXCEPT.match(unmangle( vv ))
                    if m:
                        if G_SHOW_OPTIMIZATIONS:
                            debug('[inline-nonrecursive] refusing to inline %s, matches --inline-except regex' % (
                                repr( unmangle( vv ) ),
                            ))
                        rewritten.append( command )
                        continue
                
                if any( vv.kind() == 'localfn' and vv.value() == '$.noopt' for vv in opted[vv].body().commands() ):
                    if G_SHOW_OPTIMIZATIONS:
                        debug('[inline-nonrecursive] refusing to inline into %s due to "$.noopt" in %s' % (
                            repr( unmangle( name ) ) ,
                            repr( unmangle( vv ) ) ,
                        ))
                    rewritten.append( command )
                    continue
                else:
                    changed = True
                    
                    if G_SHOW_OPTIMIZATIONS:
                        log( '[inline-nonrecursive] inlining call to %s in %s' % (
                            repr( unmangle( command.value() ) ) ,
                            repr( unmangle( name ) ) ,
                        ))
                    
                    end = '.' + vv + '.' + str(uniques.get()) + '.inline.end'
                    includeEndLabel = False
                    
                    varupdates = {}
                    for sublocal in opted[vv].body().localvars():
                        varupdates[ sublocal[0] ] = '$' + vv + '$' + str(uniques.get()) + sublocal[0]
                        newlocals.append( (varupdates[sublocal[0]], sublocal[1]) )
                    
                    # gather all nested subfns
                    # we will rewrite them in reverse order so we can swap out the names in the rewrites
                    # 
                    # (subfnId, varupdatesToPerform, subFnNewParent)
                    subFnsToScan = []
                    for subfn in opted[vv].body().commands():
                        if subfn.kind() == 'subfn':
                            if subfn.kind() == 'subfn':
                                subFnsToScan.append( (subfn.value(),varupdates,name) )
                    
                    # (subfnId,newSubfnId,subvarupdates,subFnNewParent)
                    remainingSubFns = []
                    while subFnsToScan:
                        (curSubFn,curvarupdates,curnewparent) = subFnsToScan.pop()
                        newName = '$inline_' + str(uniques.get()) + '$' + curSubFn
                        subvarupdates = dict(
                            (k,v)
                            for (k,v) in curvarupdates.items()
                            if not opted[curSubFn].body().has_local(k)
                        )
                        remainingSubFns.append( (curSubFn,newName,subvarupdates,curnewparent) )
                        for subfn in opted[curSubFn].body().commands():
                            if subfn.kind() == 'subfn':
                                subFnsToScan.append((subfn.value(),subvarupdates,newName))
                    
                    remainingSubFns = list(reversed(remainingSubFns))
                    
                    forwardJumpOptInlineNo = uniques.get()
                    
                    # we have to walk down the complete chain of subfns for the rewrite
                    subFnRewrites = {}
                    while remainingSubFns:
                        cur = remainingSubFns.pop()
                        (curSubFn, newName, varupdates, newParent) = cur
                        subFnRewrites[curSubFn] = newName
                         
                        if newName in opted:
                            raise Exception('wat')
                        
                        opted[newName] = (
                            opted[curSubFn]
                            .rewriting_name( subFnRewrites[curSubFn] )
                            .rewriting_nonlocals( varupdates )
                            .rewriting_subfns( subFnRewrites )
                            .rewriting_parent( newParent )
                        )
                    
                    for subcommand in opted[vv].body().commands():
                        if subcommand.kind() == 'localfn' and subcommand.value()[:2] != '$.':
                            lfname, lfaction = subcommand.value().split('.',1)
                            # nonlocals won't appear in the locals rewrites, allowing them to
                            # flow directly into parent functions
                            if lfname in varupdates:
                                rewritten.append( Token(
                                    location = subcommand.location()               ,
                                    kind     = 'localfn'                           ,
                                    value    = varupdates[lfname] + '.' + lfaction ,
                                ))
                            else:
                                rewritten.append( Token(
                                    location = subcommand.location() ,
                                    kind     = 'localfn'             ,
                                    value    = subcommand.value()    ,
                                ))
                        
                        elif subcommand.kind() == 'localfn' and subcommand.value() == '$.leaveIf':
                            includeEndLabel = True
                            uniqueno = uniques.get()
                            rewritten.append( Token(
                                location = subcommand.location() ,
                                kind     = 'FORWARDJUMPIF'       ,
                                value    = end                   ,
                            ))
                        elif subcommand.kind() == 'code':
                            rewritten.append( Token(
                                location = subcommand.location() ,
                                kind     = 'code'                ,
                                value    = nest_labels( uniques.get(), vv, subcommand.value() ) ,
                            ))
                        elif subcommand.kind() == 'subfn':
                            rewritten.append(Token(
                                location = subcommand.location()             ,
                                kind     = 'subfn'                           ,
                                value    = subFnRewrites[subcommand.value()] ,
                            ))
                        elif subcommand.kind() == 'FORWARDJUMPIF':
                            rewritten.append( Token(
                                location = subcommand.location() ,
                                kind     = 'FORWARDJUMPIF'       ,
                                value    = '.' + vv + '.' + str(forwardJumpOptInlineNo) + subcommand.value() ,
                            ))
                        elif subcommand.kind() == 'JUMPTARGET':
                            rewritten.append( Token(
                                location = subcommand.location() ,
                                kind     = 'JUMPTARGET'          ,
                                value    = '.' + vv + '.' + str(forwardJumpOptInlineNo) + subcommand.value(),
                            ))
                        else:
                            rewritten.append( subcommand )
                    
                    if includeEndLabel:
                        rewritten.append( Token(
                            location = subcommand.location() ,
                            kind     = 'JUMPTARGET'          ,
                            value    = end                   ,
                        ))
        else:
            rewritten.append( command )
    
    if changed:
        return True, targetfn.rewriting_locals( newlocals ).rewriting_commands( rewritten ), list(newclosures.values())
    else:
        return False, targetfn, []

def nest_labels( uniqueno, prefix, code ):
    if '===' not in code:
        return nest_labels_munge( uniqueno, prefix, code )
    
    sections = parse_code_sections( IMPLEMENTATION, code )
    
    for section in sections:
        if not (section['headers'].get('impl',IMPLEMENTATION) == IMPLEMENTATION):
            continue
        elif not (section['headers'].get('type','code') == 'code'):
            continue
        else:
            section['body'] = nest_labels_munge( uniqueno, prefix, section['body'] )
    
    return unparse_code_sections( sections )
    
def nest_labels_munge( uniqueno, prefix, code ):
    
    isLocalLabel = re.compile( '(?P<before>.*)(?P<current>[.][A-Za-z_-]*)(?P<after>.*)' )
    
    rewritten = []
    for line in code.split("\n"):
        m = isLocalLabel.match( line )
        if m:
            rewritten.append(
                m.group('before')
                +
                '.' + prefix
                +
                '.' + str(uniqueno)
                + 
                m.group('current')
                + m.group('after')
            )
        else:
            rewritten.append( line )
    return '\n'.join(rewritten)

# this optimization pass runs the programs encoded into assembly segments
# that dictate various replacements optimizations that can be run to transform
# the runtime assembly into compiletime token manipulations
# 
def optimize_perform_token_replacements( notes, recursive, opted, name, targetfn, uniques ):
    
    rewritten = []
    changed = False
    
    for command in targetfn.body().commands():
        if command.kind() != 'code':
            rewritten.append( command )
            continue
        
        if '===' not in command.value():
            rewritten.append( command )
            continue
        
        for section in parse_code_sections( IMPLEMENTATION, command.value() ):
            if not (section['headers'].get('impl', IMPLEMENTATION) == IMPLEMENTATION):
                if G_SHOW_OPTIMIZATIONS:
                    debug( '[token-replacements] skipping section, wrong impl: %s' % repr( section ) )
                continue
            
            if not (section['headers'].get('type','code') == 'token-replace'):
                if G_SHOW_OPTIMIZATIONS:
                    debug( '[token-replacements] skipping section, wrong type: %s' % repr( section ) )
                continue
            
            when = section['headers'].get('when', None)
            if when == None:
                raise Exception( 'you cannot have a rewrite rule with no when' )
            
            constraints = [ e.strip() for e in when.split(',') ]
            matches = True
            for index, constraint in enumerate( reversed( constraints ) ):
                if constraint == 'I':
                    if index >= len( rewritten ):
                        matches = False
                        break
                    elif rewritten[-index-1].kind() != 'integer':
                        matches = False
                        break
                else:
                    raise Exception( 'unknown when constraint: %s, in %s' % ( repr( constraint ), repr( command ) ) )
            
            if not matches:
                continue
            
            changed = True
            
            relevant = rewritten[-len(constraints):None]
            rewritten = rewritten[None:-len(constraints)]
            
            gs = globals().copy()
            gs['self'] = command
            todo = eval( section['body'], gs )
            
            new = todo( *relevant )
            
            if G_SHOW_OPTIMIZATIONS:
                log( '[token-replacements] replaced %s with %s' % (
                    (
                        tuple(r.value() for r in relevant)
                        +
                        (
                            (repr( command.location() ),)
                            if not section['headers'].get('name',None) else
                            (section['headers'].get('name'),)
                        )
                    ),
                    tuple(n.value() for n in new),
                ))
            
            for n in new:
                rewritten.append( n )
            
            break
            
        else:
            if G_SHOW_OPTIMIZATIONS:
                debug( '[fetch-rewrite-rule] no matching rewrite rule for %s' % repr( command ) )
            rewritten.append( command )
    
    if changed:
        return True, targetfn.rewriting_commands( rewritten ), []
    else:
        return False, targetfn, []

def optimize_propagate_localfn_constants( notes, recursive, opted, name, targetfn, uniques ):
    
    # we only propagate the locals here, we'll strip out unused sets in another step
    
    # rules:
    #   if a set is performed after a constant
    #   if we encounter a nonlocalsafe codeblock we have to forget the locals we are replacing
    #   
    #   until we reach another set
    #   
    
    addressed = set()
    replacements = {}
    
    rewritten = []
    changed = False
    for index, command in enumerate( targetfn.body().commands() ):
        
        if command.kind() == 'code':
            if '===' in command.value():
                sections = parse_code_sections( IMPLEMENTATION, command.value() )
                for section in sections:
                    if 'locals' in [ e.strip() for e in section['headers'].get('writes','').split(',') ]:
                        # locals are not safe in this code!
                        # kill our replacements cache
                        if G_SHOW_OPTIMIZATIONS:
                            debug('[propagate-localfn-constants] encountered code with "writes: locals", dropping replacements')
                        replacements = {}
                    else:
                        # locals are safe in this code!
                        # no need to drop replacements
                        if G_SHOW_OPTIMIZATIONS:
                            debug('[propagate-localfn-constants] assuming code without "writes: locals" doesn\'t' )
            else:
                # unstructured code can do anything
                # drop all local references
                if G_SHOW_OPTIMIZATIONS:
                    debug('[propagate-localfn-constants] encountered unstructured code, dropping replacements')
                replacements = {}
            rewritten.append( command )
            continue
        
        if command.kind() != 'localfn':
            rewritten.append( command )
            continue
        
        vv = command.value()
        if vv.startswith('$.'):
            rewritten.append( command )
            continue
        
        if not rewritten:
            rewritten.append( command )
            continue
        
        name, fn = vv.split('.',1)
        
        if fn == 'set':
            if rewritten[-1].kind() in ['integer', 'string']:
                replacements[ name ] = rewritten[-1]
            elif name in replacements:
                del replacements[ name ]
            rewritten.append( command )
            continue
        
        if fn == 'get':
            if name in replacements:
                if G_SHOW_OPTIMIZATIONS:
                    log('[propagate-localfn-constants] replacing %s with constant %s' % (
                        repr( command ) ,
                        repr( replacements[ name ] ) ,
                    ))
                changed = True
                rewritten.append( replacements[ name ] )
                continue
            else:
                rewritten.append( command )
                continue
        
        if fn == 'here':
            # we can do better than this
            # we can check what subset of locals are used until the associated name is .addr, .get or .jump'd
            # if we hit another <name>.here it's a new loop and we'd have to check that separately
            # for now, though, we'll just conservatively assume 'loop starts == dead locals'
            if G_SHOW_OPTIMIZATIONS:
                log(
                    '[propagate-localfn-constants] dropping all replacements on encountering potential loop start: %s' % (
                        repr( command ),
                    )
                )
            replacements = {}
            rewritten.append( command )
            continue
        
        if fn == 'addr':
            if name in replacements:
                del replacements[ name ]
            addressed.add( name )
            
        if fn == 'incr':
            if name in replacements:
                if replacements[ name ].kind() == 'integer':
                    if G_SHOW_OPTIMIZATIONS:
                        log('[propagate-localfn-constants] incrementing constant local replacement: %s' % repr( command ) )
                    replacements[ name ] = Token(
                        location = replacements[ name ].location() ,
                        kind     = 'integer' ,
                        value    = replacements[ name ].value() + 1 ,
                    )
                    rewritten.append( command )
                    continue
                else:
                    del replacements[ name ]
                    rewritten.append( command )
                    continue
            else:
                rewritten.append( command )
                continue
        
        if fn == 'decr':
            if name in replacements:
                if replacements[ name ].kind() == 'integer':
                    if G_SHOW_OPTIMIZATIONS:
                        log('[propagate-localfn-constants] decrementing constant local replacement: %s' % repr( command ) )
                    replacements[ name ] = Token(
                        location = replacements[ name ].location() ,
                        kind     = 'integer' ,
                        value    = replacements[ name ].value() - 1 ,
                    )
                    rewritten.append( command )
                    continue
                else:
                    del replacements[ name ]
                    rewritten.append( command )
                    continue
            else:
                rewritten.append( command )
                continue
        
        if fn == 'jump':
            rewritten.append( command )
            continue
        
        if fn == 'jumpIf':
            rewritten.append( command )
            continue
        
        if fn == 'update':
            if rewritten and rewritten[-1].kind() == 'fnref':
                fnref = rewritten[-1]
                rewritten = rewritten[:-1]
                rewritten.append( Token(
                    location = command.location() ,
                    kind     = 'localfn',
                    value    = name + '.get',
                ))
                rewritten.append( fnref )
                rewritten.append( Token(
                    location = comamnd.location() ,
                    kind = 'localfn',
                    value = '$.call',
                ))
                rewritten.append( Token(
                    location = command.location() ,
                    kind     = 'localfn' ,
                    value    = name + 'set',
                ))
            else:
                rewritten.append( command )
                continue
        
        if fn == 'call':
            rewritten.append( command )
            continue
        
        if fn == 'copy':
            rewritten.append( command )
            continue
        
        raise Exception( '[propagate-localfn-constants] unknown localfn: %s' % repr( command ) )
    
    if changed:
        return True, targetfn.rewriting_commands( rewritten ), []
    else:
        return False, targetfn, []

# returnindex + 1
# newframe = stack + sizeof( returnframe = 16) * returnindex
# newframe[0] = fn_0
# newframe[1] = 0
# goto command

def generate_code(
    functions           ,
    usedFunctions       ,
    startname           ,
    trampolineSize      ,
    trampolineEndOffset ,
):
    stringCoalescer = StringCoalescer()
    
    staticStrings = set()
    
    pre  = []
    data = []
    code = []
    bss  = []
    
    uniques = Uniques()
    
    bss.append( 'section .bss\n' )
    bss.append( 'datastack: resq 1\n' )
    bss.append( 'callstack: resq 1\n' )
    bss.append( '\n' )
    
    data.append( 'section .data\n' )
    data.append( '\n' )
    
    code.append( 'section .text\n' )
    
    code.append( 'global _start\n')
    code.append( '\n')
    
    code.append( '; this trampoline is copied into the stack to enable closures\n' )
    code.append( '; it uses position independent instruction-pointer relative load effective address\n' )
    code.append( '; to find its jump return. it also ensures the return jump takes up the space we think it does\n' )
    code.append( '; we copy this into a stack frame for each closure the function references\n' )
    code.append( '; then, instead of passing the value of the closure, we pass this thing\n')
    code.append( '; when someone goes to call the closure, it calls this, which is in the stack of the binding callframe\n')
    code.append( '; this pushes its return address and jumps to the actual function to be called\n' )
    code.append( '; that function then resolves any parent locals relative to the return address, as they will follow the closures\n')
    code.append( '; this allows us to send a normal x64 points around, but one that is able to find its origin frame and locals!\n')
    code.append( '; this will make debugging hell and make any stack corruption a hundred times worse\n')
    code.append( '; it is perfect for kmforth\n')
    code.append( ' align 64\n')
    code.append( '_trampoline:\n')
    code.append( ' lea rax, [rel .trampoline_return]\n')
    code.append( ' mov [r15], rax\n')
    code.append( ' add r15, 8\n')
    code.append( ' mov rax, qword [rel .trampoline_target]\n')
    code.append( ' jmp rax\n' )
    code.append( ' align 8\n' )
    code.append( '.trampoline_return:\n')
    code.append( ' sub r15, 8\n' )
    code.append( ' jmp [r15]\n' )
    code.append( ' align 8\n' )
    code.append( '.trampoline_target:\n')
    code.append( '\n')
    code.append( '\n' )
    code.append( 'align 64\n')
    code.append( '_start:\n' )
    code.append( '    jmp %s\n' % startname )
    code.append( '\n')
    
    nn = 0
    for fn in functions:
        
        # 'tree shaking'
        if fn not in usedFunctions:
            continue
        
        code.append( '\n' )
        code.append( '; %s\n' % repr( functions[fn].location() ) )
        code.append( '  ' + fn + ':\n' )
        
        localfns = LocalFns(
            uniques             = uniques             ,
            functions           = functions           ,
            fn                  = fn                  ,
            trampolineSize      = trampolineSize      ,
            trampolineEndOffset = trampolineEndOffset ,
        )
        
        frameOffsets = functions[ fn ].body().frame_offsets(
            functions           = functions           ,
            trampolineSize      = trampolineSize      ,
            trampolineEndOffset = trampolineEndOffset ,
        )
        
        if frameOffsets.frame_total_size():
            code.append( '  ; make space for any closure trampolines and locals\n' )
            code.append( '  add r15, %d\n' % ( frameOffsets.frame_total_size() ) )

        if trampolineSize != 32:
            raise Exception( 'need to make this general' )
        
        for closureName in frameOffsets.nonlocalvar_names():
            code.append( ' ; copy the trampoline code into the stack\n' )
            code.append( '  mov rax, [_trampoline]\n' )
            code.append( '  mov qword [r15-8*%d], rax\n' % (
                frameOffsets.nonlocalvar_trampoline_slotno( closureName ),
            ))
            code.append( '  mov rax, [_trampoline+8]\n' )
            code.append( '  mov qword [r15-8*%d+8], rax\n' % (
                frameOffsets.nonlocalvar_trampoline_slotno( closureName ),
            ))
            code.append( '  mov rax, [_trampoline+16]\n' )
            code.append( '  mov qword [r15-8*%d+16], rax\n' % (
                frameOffsets.nonlocalvar_trampoline_slotno( closureName ),
            ))
            code.append( '  mov rax, [_trampoline+24]\n' )
            code.append( '  mov qword [r15-8*%d+24], rax\n' % (
                frameOffsets.nonlocalvar_trampoline_slotno( closureName ),
            ))
            code.append( ' ; and the trampoline target right after it\n' )
            code.append( '  mov qword [r15-8*%d], %s\n' % (
                frameOffsets.nonlocalvar_target_slotno( closureName ),
                closureName
            ))
        
        for command in functions[ fn ].body().commands():
            
            if command.kind() == 'word':
                rt = '.' + fn + '_' + str( nn )
                nn = nn + 1
                
                code.append( '    ; calling %s\n' % unmangle(command.value()) )
                code.append( '    mov qword [r15], %s\n' % rt )
                code.append( '    add r15, 8\n' )
                code.append( '    jmp ' + command.value() + '\n' )
                code.append( '  %s:\n' % rt )
                
            elif command.kind() == 'code':
                code.append( '\n' )
                code.append( '; including code literal\n' )
                code.append( fetch_code(
                    impl = IMPLEMENTATION ,
                    data = command.value() ,
                ))
                code.append( '\n' )
                
            elif command.kind() == 'string':
                
                sn = stringCoalescer.lookup( command.value() )
                if not sn:
                    sn = "km_c_" + str(uniques.get())
                    data.append( '  ' + sn + ':\n' )
                    # convert \n into 10 here ( 10, 13 for windows, but fuck those guys
                    data.append( "    db %s\n" % asm_stringize( command.value() ) )
                    stringCoalescer.remember( command.value(), sn )
                    
                code.append( '   ; pushing string literal %s\n' % repr( command.value() ) )
                code.append( '   mov qword [r14], %s\n' % sn )
                code.append( '   add r14, 8\n' )
                
            elif command.kind() == 'integer':
                # 
                # you can't write an immediate larger than a 32bit value directly to memory
                # you have to load the value into a register and use the register command form
                # 
                if command.value() > (4294967296 - 1):
                    code.append( '   ; push integer > 32bit\n' )
                    code.append( '   mov rax, %s\n' % command.value() )
                    code.append( '   mov [r14],rax\n' )
                    code.append( '   add r14,8\n' )
                else:
                    code.append( '   ; push integer < 32bit\n' )
                    code.append( '   mov qword [r14], %s\n' % command.value() )
                    code.append( '   add r14, 8\n' )
            
            # user code can't create a FORWARDJUMPIF, but optimization passes can
            elif command.kind() == 'FORWARDJUMPIF':
                code.append( INLINED_LEAVEIF % { 'endlabel' : command.value() } )
                
            # user code can't create a JUMPTARGET, but optimization passes can
            elif command.kind() == 'JUMPTARGET':
                code.append( command.value() + ":\n" )
            
            elif command.kind() == 'localfn':
                if command.value().startswith('$.'):
                    builtin = command.value()
                    # no localfn for unconditional call, just use 'call'
                    if builtin == '$.callIf':
                        localfns.implementation_callIf( code )
                    elif builtin == '$.jumpIf':
                        localfns.implementation_jumpIf( code )
                    elif builtin == '$.jump':
                        localfns.implementation_jump( code )
                    elif builtin == '$.leaveIf':
                        localfns.implementation_leaveIf( code )
                    elif builtin == '$.call':
                        localfns.implementation_call( code )
                    elif builtin == '$.noopt':
                        # this just prevents inlining the function or inlining into the function
                        pass
                    else:
                        raise Exception( 'unknown builtin localfn: %s' % repr( command.value() ) )
                else:
                    # locals getters and setters
                    commandBits = command.value().split('.',1)
                    if len( commandBits ) != 2:
                        raise Exception( 'command-bits length not 2? %s' % repr( commandBits ) )
                    localName, memberfn = commandBits
                    
                    localvar = localfns.localvar( localName )
                    
                    if memberfn == 'get':
                        localvar.implementation_get( code )
                    elif memberfn == 'set':
                        localvar.implementation_set( code )
                    elif memberfn == 'update':
                        localvar.implementation_update( code )
                    elif memberfn == 'call':
                        localvar.implementation_call( code )
                    elif memberfn == 'copy':
                        localvar.implementation_copy( code )
                    elif memberfn == 'here':
                        localvar.implementation_here( code )
                    elif memberfn == 'jump':
                        localvar.implementation_jump( code )
                    elif memberfn == 'jumpIf':
                        localvar.implementation_jumpIf( code )
                    elif memberfn == 'addr':
                        localvar.implementation_addr( code )
                    elif memberfn == 'incr':
                        localvar.implementation_incr( code )
                    elif memberfn == 'decr':
                        localvar.implementation_decr( code )
                    else:
                        raise Exception( 'unknown localfn ( expecting <local>.get or <local>.set ): %s' % repr( command.value() ) )
                    
            elif command.kind() == 'fnref':
                code.append( '    ; push reference to fn\n' )
                code.append( '    mov qword [r14], %s\n' % command.value() )
                code.append( '    add r14, 8\n' )
                
            elif command.kind() == 'subfn':
                if functions[ command.value() ].is_closure( functions ):
                    # needs a trampoline for nonlocal access
                    code.append( ' ; for subfn, push closure (%s) trampoline reference\n' % repr( command.value() ))
                    code.append( ' lea rax, [r15+8*%d]\n' % (- frameOffsets.nonlocalvar_trampoline_slotno( command.value())))
                    code.append( ' mov qword [r14], rax\n' )
                    code.append( ' add r14, 8\n' )
                else:
                    # normal c-style function pointer
                    code.append( '    ; push subfn reference\n' )
                    code.append( '    mov qword [r14], %s\n' % command.value() )
                    code.append( '    add r14, 8\n' )
            else:
                raise Exception( 'wat %s %s' % ( str( command.kind() ), repr( command.value() ) ) )
        
        if frameOffsets.frame_total_size():
            code.append( '    ; pop any trampolines and locals\n' )
            code.append( '    sub r15, %d\n' % ( frameOffsets.frame_total_size() ) )
            
        code.append( '    ; pop and jump to caller\n' )
        code.append( '    sub r15, 8\n' )
        code.append( '    jmp [r15]\n' )
        
    return '\n'.join( [''.join(pre), ''.join( data ), ''.join( code ), ''.join( bss ) ] )
    
    
class LocalFns:
    def __init__(
        self                ,
        uniques             ,
        functions           ,
        fn                  ,
        trampolineSize      ,
        trampolineEndOffset ,
    ):
        self._uniques             = uniques
        self._functions           = functions
        self._fn                  = fn
        self._trampolineSize      = trampolineSize
        self._trampolineEndOffset = trampolineEndOffset
        
        self._frameOffsets = functions[ fn ].body().frame_offsets(
            functions           = functions           ,
            trampolineSize      = trampolineSize      ,
            trampolineEndOffset = trampolineEndOffset ,
        )
        
        self._body = functions[ fn ].body()
        return
    
    def localvar( self, localVarName ):
        return LocalVarFns(
            uniques             = self._uniques             ,
            functions           = self._functions           ,
            fn                  = self._fn                  ,
            localVarName        = localVarName              ,
            frameOffsets        = self._frameOffsets        ,
            trampolineSize      = self._trampolineSize      ,
            trampolineEndOffset = self._trampolineEndOffset ,
        )
    
    def implementation_callIf( self, code ):
        label = '.km_nocall_' + str(self._uniques.get())
        code.append( '    ; callIf localfn\n' )
        code.append( '    sub r14, 8\n' )                  # pop todo
        code.append( '    mov rax, [r14]\n' )
        code.append( '    sub r14, 8\n' )                  # pop cond
        code.append( '    mov rbx, [r14]\n' )
        code.append( '    test rbx,rbx\n' )                # test setting zf
        code.append( '    jz %s\n' % label )               # jump over call if 0
        code.append( '    mov qword [r15], %s\n' % label ) # push return label onto callstack
        code.append( '    add r15, 8\n' )
        code.append( '    jmp rax\n' )                     # go
        code.append( '   %s:\n' % label )                  # return label
        
    def implementation_jumpIf( self, code ):
        label = '.km_nojump_' + str(self._uniques.get())
        code.append( '    ; jumpIf \n' )
        code.append( '    sub r14, 8\n' )     # pop jump target
        code.append( '    mov rax, [r14]\n' )
        code.append( '    sub r14, 8\n' )     # pop cond
        code.append( '    mov rbx, [r14]\n' )
        code.append( '    test rbx,rbx\n' )   # test cond
        code.append( '    jz %s\n' % label )  # jump over jump if 0
        code.append( '    jmp rax\n' )        # jump
        code.append( '   %s:\n' % label )     # don't
        
    def implementation_jump( self, code ):
        code.append( '    ; jump\n' )
        code.append( '    sub r14, 8\n' )
        code.append( '    jmp [r14]\n' )
        
    def implementation_leaveIf( self, code ):
        label = '.km_noleave_' + str(self._uniques.get())
        code.append( '    ; leaveIf\n' )
        code.append( '    sub r14, 8\n' )
        code.append( '    mov rax, [r14]\n' )
        code.append( '    test rax,rax\n' )
        code.append( '    jz %s\n' % label )
        if self._frameOffsets.frame_total_size():
            code.append( '    ; (popping locals before leaving)\n' )
            code.append( '    sub r15, %d\n' % ( self._frameOffsets.frame_total_size() ) )
        code.append( '    sub r15, 8\n' )
        code.append( '    jmp [r15]\n' )
        code.append( '   %s:\n' % label )
        
    def implementation_call( self, code ):
        label = '.km_return_'+  str(self._uniques.get())
        code.append( '    ; $.call\n' )
        code.append( '    mov qword [r15], %s\n' % label )
        code.append( '    add r15, 8\n' )
        code.append( '    sub r14, 8\n' )
        code.append( '    jmp [r14]\n' )
        code.append( label + ':\n' )
        

# we don't need to care what the parent is in the code, just how many indirections
# are required to get to a certain variable. we will then need to make usage of that
# variable perform the correct number of parent hops and get/set/addr the local in
# the resulting frame.
# we always know the number of hops for a given variable, because a closer is only
# created by having them inside other functions or closures
# 
class LocalVarFns:
    def __init__(
        self                ,
        uniques             ,
        functions           ,
        fn                  ,
        localVarName        ,
        frameOffsets        ,
        trampolineSize      ,
        trampolineEndOffset ,
    ):
        self._uniques             = uniques
        self._functions           = functions
        self._fn                  = fn
        self._localVarName        = localVarName
        self._frameOffsets        = frameOffsets
        self._trampolineSize      = trampolineSize
        self._trampolineEndOffset = trampolineEndOffset
        
        self._slotno, self._indirections = self._determine_slotno_and_indirections(
            trampolineSize      = trampolineSize      ,
            trampolineEndOffset = trampolineEndOffset ,
        )
        
        return
    
    def _determine_slotno_and_indirections(
        self                ,
        trampolineSize      ,
        trampolineEndOffset ,
    ):
        indirections = []
        cfn = self._fn
        while True:
            frameOffsets = self._functions[ cfn ].body().frame_offsets(
                functions           = self._functions     ,
                trampolineSize      = trampolineSize      ,
                trampolineEndOffset = trampolineEndOffset ,
            )
            slotno = frameOffsets.localvar_slotno( self._localVarName )
            if slotno != None:
                break
            
            cfn = self._functions[ cfn ].parent()
            indirections.append( cfn )
            
            if cfn != None:
                continue
            else:
                raise Exception( 'cannot locate localvar named (%s) in function (%s @ %s)' % (
                    repr(self._localVarName),
                    repr(self._fn),
                    repr(self._functions[self._fn].location()),
                ))
        return slotno, indirections
    
    def _walk_to_target_frame( self, code ):
        code.append( ' ; walking trampoline\n' )
        code.append( ' ; get return-address\n' )
        # the return address is one slot past the end of the frame
        code.append( ' mov rax, [r15+8*%d+8*%d]\n' % (
            - self._frameOffsets.frame_slots_used(),
            - 1
        ))
        remaining = list( self._indirections )
        last = remaining.pop()
        penultimate = self._fn
        for cfn in remaining:
            parentFrameOffsets = self._functions[ cfn ].body().frame_offsets(
                functions           = self._functions           ,
                trampolineSize      = self._trampolineSize      ,
                trampolineEndOffset = self._trampolineEndOffset ,
            )
            code.append( ' ; get next return-address\n' )
            code.append( ' mov rax, [rax+8*%d+8*%d+8*%d+8*%d+8*%d]\n' % (
                + (self._trampolineEndOffset // 8),
                - (self._trampolineSize // 8),
                + parentFrameOffsets.nonlocalvar_trampoline_slotno( penultimate ),
                - parentFrameOffsets.frame_slots_used(),
                - 1,
            ))
            penultimate = cfn
        lastFrameOffsets = self._functions[ last ].body().frame_offsets(
            functions           = self._functions           ,
            trampolineSize      = self._trampolineSize      ,
            trampolineEndOffset = self._trampolineEndOffset ,
        )
        return last, lastFrameOffsets, '[rax+8*%d+8*%d+8*%d+8*%d]' % (
                + (self._trampolineEndOffset // 8),
                - (self._trampolineSize // 8),
                + lastFrameOffsets.nonlocalvar_trampoline_slotno( penultimate ),
                - lastFrameOffsets.localvar_slotno( self._localVarName ),
        )

    def _require_slot_sized( self, getSizeFn, name ):
        if getSizeFn( name ) != 8:
            a = 'you can only .get, .set, .update, .call and .here vars of size 8. other sizes only offer .addr, '
            b = 'found %s in %s which is size %s' % (
                repr( name ),
                repr( unmangle( self._fn ) ),
                repr( getSizeFn( name ) ) ,
            )
            raise Exception( a + b )
    
    def implementation_get( self, code ):
        if self._indirections:
            parent, parentOffsets, addr = self._walk_to_target_frame( code )
            self._require_slot_sized( parentOffsets.localvar_size, self._localVarName )
            code.append( '   ; push nonlocal (%s) to datastack\n' % repr( self._localVarName ) )
            code.append( '   mov rax, %s\n' % addr )
            code.append( '   mov qword [r14], rax\n' )
            code.append( '   add r14, 8\n' )
            return
        else:
            self._require_slot_sized( self._frameOffsets.localvar_size, self._localVarName )
            code.append( '    ; push local (%s) to datastack\n' % repr( self._localVarName ) )
            code.append( '    mov rax, [r15-8*%d]\n' % (self._slotno) )
            code.append( '    mov qword [r14], rax\n' )
            code.append( '    add r14, 8\n' )
        
    def implementation_set( self, code ):
        if self._indirections:
            parent, parentOffsets, addr = self._walk_to_target_frame( code )
            self._require_slot_sized( parentOffsets.localvar_size, self._localVarName )
            code.append( '    ; pop datastack storing to nonlocal (%s)\n' % repr( self._localVarName ))
            code.append( '    sub r14, 8\n')
            code.append( '    mov rbx, [r14]\n' )
            code.append( '    mov qword %s, rbx\n' % addr )
        else:
            self._require_slot_sized( self._frameOffsets.localvar_size, self._localVarName )
            code.append( '    ; pop datastack storing to local (%s)\n' % ( repr( self._localVarName ) ) )
            code.append( '    sub r14, 8\n' )
            code.append( '    mov rax, [r14]\n' )
            code.append( '    mov qword [r15-8*%d], rax\n' % (self._slotno) )
            
    def implementation_update( self, code ):
        if self._indirections:
            parent, parentOffsets, addr = self._walk_to_target_frame( code )
            self._require_slot_sized( parentOffsets.localvar_size, self._localVarName )
            label = '.km_update_nonlocal_' + str(self._uniques.get())
            code.append('    ; update value of nonlocal %s by getting, invoking and setting\n' % repr( self._localVarName ))
            code.append('    mov rbx, [r14-8]\n')
            code.append('    mov rax, %s\n' % addr)
            code.append('    mov [r14-8], rax\n')
            code.append('    mov qword [r15], %s\n' % label)
            code.append('    add r15, 8\n')
            code.append('    jmp rbx\n')
            code.append(' %s:\n' % label)
            # recalculate addr because we don't have anywhere to save it and registers aren't save across calls
            parent, parentOffsets, addr = self._walk_to_target_frame( code )
            code.append('    mov rbx, [r14-8]\n')
            code.append('    sub r14, 8\n')
            code.append('    mov qword %s, rbx\n' % addr)
            code.append('    ; end non-local update\n')
        else:
            self._require_slot_sized( self._frameOffsets.localvar_size, self._localVarName )
            label = '.km_update_local_' + str(self._uniques.get())
            code.append('    ; update value of local %s by getting, invoking and setting\n' % repr( self._localVarName ))
            code.append('    mov rbx, [r14-8]\n')
            code.append('    mov rax, [r15+8*%d]\n' % (- self._slotno))
            code.append('    mov qword [r14-8], rax\n')
            code.append('    mov qword [r15], %s\n' % label)
            code.append('    add r15, 8\n')
            code.append('    jmp rbx\n')
            code.append(' %s:\n' % label)
            code.append('    mov rax, [r14-8]\n')
            code.append('    sub r14, 8\n')
            code.append('    mov qword [r15+8*%d], rax\n' % (- self._slotno))
            code.append('    ; end local update\n')
    
    def implementation_call( self, code ):
        if self._indirections:
            parent, parentOffsets, addr = self._walk_to_target_frame( code )
            self._require_slot_sized( parentOffsets.localvar_size, self._localVarName )
            label = '.km_call_nonlocal_' + str(self._uniques.get())
            code.append( '    mov qword [r15], %s\n' % label )
            code.append( '    add r15, 8\n' )
            code.append( '    jmp %s\n' % addr )
            code.append( ' %s:\n' % label )
        else:
            label = '.km_call_local_' + str(self._uniques.get())
            code.append( '    mov rbx, [r15+8*%d]\n' % (- self._slotno))
            code.append( '    mov qword [r15], %s\n' % label )
            code.append( '    add r15, 8\n' )
            code.append( '    jmp rbx\n' )
            code.append( ' %s:\n' % label )
    
    def implementation_copy( self, code ):
        if self._indirections:
            parent, parentOffsets, addr = self._walk_to_target_frame( code )
            self._require_slot_sized( parentOffsets.localvar_size, self._localVarName )
            code.append( '    ; copy top of datastack to nonlocal (%s)\n' % ( repr( self._localVarName ) ) )
            code.append( '    mov rbx, [r14-8]\n' )
            code.append( '    mov qword %s, rbx\n' % addr )
        else:
            self._require_slot_sized( self._frameOffsets.localvar_size, self._localVarName )
            code.append( '    ; copy datastack to local (%s)\n' % ( repr( self._localVarName ) ) )
            code.append( '    mov rax, [r14-8]\n' )
            code.append( '    mov qword [r15-8*%d], rax\n' % (self._slotno) )
    
    def implementation_here( self, code ):
        if self._indirections:
            # 
            # there is no reasonable reason to ever store a nonlocal here
            # I'll allow it
            #
            parent, parentOffsets, addr = self._walk_to_target_frame( code )
            self._require_slot_sized( self._parentOffsets.localvar_size, self._localVarName )
            label = '.km_here_nonlocal_' + str(self._uniques.get())
            code.append( '    ; set local (%s) to label following this command\n' % repr(self._localVarName) )
            code.append( '    mov qword %s, %s\n' % (addr, label))
            code.append( '    %s:\n' % label )
        else:
            self._require_slot_sized( self._frameOffsets.localvar_size, self._localVarName )
            label = '.km_here_' + str(self._uniques.get())
            code.append( '    ; set local (%s) to label following this command\n' % repr(self._localVarName))
            code.append( '    mov qword [r15-8*%d], %s\n' % ( (self._slotno), label) )
            code.append( '    %s:\n' % label )
        
    def implementation_jump( self, code ):
        if self._indirections:
            parent, parentOffsets, addr = self._walk_to_target_frame( code )
            self._require_slot_sized( parentOffsets.localvar_size, self._localVarName )
            code.append( '    jump %s\n' % addr )
        else:
            self._require_slot_sized( self._frameOffsets.localvar_size, self._localVarName )
            code.append( '    jmp qword [r15+8*%d]\n' % (- self._slotno) )
        
    def implementation_jumpIf( self, code ):
        if self._indirections:
            label = '.km_dont_jumpif_nonlocal_' + str(self._uniques.get())
            code.append( '    sub r14,8\n' )
            code.append( '    mov rbx,[r14]\n' )
            code.append( '    test rbx,rbx\n' )
            code.append( '    jz %s\n' % label )
            parent, parentOffsets, addr = self._walk_to_target_frame( code )
            self._require_slot_sized( parentOffsets.loclvar_size, self._localVarName )
            code.append( '    jmp %s\n' % addr )
            code.append( '%s:\n' % label )
        else:
            self._require_slot_sized( self._frameOffsets.localvar_size, self._localVarName )
            label = '.km_dont_jumpif_' + str(self._uniques.get())
            code.append( '    sub r14,8\n' )
            code.append( '    mov rax,[r14]\n' )
            code.append( '    test rax,rax\n' )
            code.append( '    jz %s\n' % label )
            code.append( '    jmp [r15-8*%d]\n' % (self._slotno) )
            code.append( '%s:\n' % label )

    def implementation_addr( self, code ):
        if self._indirections:
            parent, parentOffsets, addr = self._walk_to_target_frame( code )
            code.append( '    ; push address of nonlocal (%s) onto stack\n' % repr( self._localVarName ) )
            code.append( '    lea rax, %s\n' % addr )
            code.append( '    mov [r14],rax\n' )
            code.append( '    add r14,8\n' )
        else:
            code.append( '    ; push address of local (%s) onto stack\n' % repr( self._localVarName ) )
            code.append( '    lea  rax,[r15-8*%d]\n' % (self._slotno) )
            code.append( '    mov  [r14],rax\n' )
            code.append( '    add  r14,8\n' )
        
    def implementation_incr( self, code ):
        if self._indirections:
            parent, parentOffsets, addr = self._walk_to_target_frame( code )
            self._require_slot_sized( parentOffsets.localvar_size, self._localVarName )
            code.append( '    ; incr nonlocal (%s) in-place\n' % repr( self._localVarName ) )
            code.append( '    inc qword %s\n' % addr )
        else:
            self._require_slot_sized( self._frameOffsets.localvar_size, self._localVarName )
            code.append( '    ; incr local (%s) in-place\n' % repr( self._localVarName ) )
            code.append( '    inc qword [r15-8*%d]\n' % (self._slotno) )

    def implementation_decr( self, code ):
        if self._indirections:
            parent, parentOffsets, addr = self._walk_to_target_frame( code )
            self._require_slot_sized( parentOffsets.localvar_size, self._localVarName )
            code.append( '    ; decr nonlocal (%s) in-place\n' % repr( self._localVarName ) )
            code.append( '    dec qword %s\n' % addr )
        else:
            self._require_slot_sized( self._frameOffsets.localvar_size, self._localVarName )
            code.append( '    ; decr local (%s) in-place\n' % repr( self._localVarName ) )
            code.append( '    dec qword [r15-8*%d]\n' % (self._slotno) )
    
def asm_stringize( ss ):
    bits      = []
    instr     = False
    for cc in ss:
        if cc.lower() in ' abcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()[]{}|,:-/':
            if instr:
                bits.append( cc )
                continue
            else:
                if bits:
                    bits.append( ',' )
                bits.append( "'" )
                bits.append( cc )
                instr = True
        else:
            if instr:
                bits.append( "'")
                instr = False
            first = None
            for bit in cc.encode('utf-8').hex():
                if first == None:
                    first = bit
                else:
                    if bits:
                        bits.append( ',' )
                    bits.append( '0x' + first + bit )
                    first = None
    if instr:
        bits.append( "'" )
    
    if bits:
        bits.append(',')
    
    bits.append( '0' )
    
    return ''.join( bits )

def fetch_code( impl, data ):
    if '===' not in data:
        return data
    
    for section in parse_code_sections( impl, data ):
        
        if not (section['headers'].get('impl', impl) == impl):
            if G_SHOW_OPTIMIZATIONS:
                debug( '[fetch-code] skipping section, wrong impl: %s' % repr( section ) )
            continue
        
        if not (section['headers'].get('type','code') == 'code'):
            if G_SHOW_OPTIMIZATIONS:
                debug( '[fetch-code] skipping section, wrong type: %s' % repr( section ) )
            continue
        
        if not (section['headers'].get('when', '').strip() == ''):
            if G_SHOW_OPTIMIZATIONS:
                debug( '[fetch-code] skipping section, has conditional: %s' % repr( section ) )
            continue
        
        return section['body']
    
    raise Exception( 'no appropriate code section found: %s' % repr( data ) )
    
def parse_code_sections( impl, data ):
    lines = Source( data.strip().split('\n') )
    
    done = False
    sections = []
    while True:
        headers = {}
        while True:
            line = lines.take()
            if line == None:
                done = True
                break
            elif '===' in line:
                raise Exception( 'cannot have === in headers section, separate headers by at least one blank line, in %s' % (
                    repr( data ) ,
                ))
            elif line.strip() == "":
                break
            else:
                name, value = line.strip().split(':',1)
                name = name.strip()
                value = value.strip()
                headers[ name ] = value
        
        if done:
            break
        
        body = []
        while True:
            line = lines.take()
            if line == None:
                done = True
                break
            elif '===' in line:
                break
            else:
                body.append( line )
        
        sections.append({'headers' : headers, 'body' : '\n'.join(body) + '\n'})
        
        if done:
            break
    
    return sections

def unparse_code_sections( sections ):
    bits = []
    
    for section in sections:
        for header in section['headers'].items():
            bits.append( '%s : %s' % ( header[0], header[1] ) )
        
        bits.append( '' )
        
        bits.append( section['body'] )
        
        bits.append( '===' )
    
    return '\n'.join( bits[:-1] )

#####

class AsmFunction:
    
    def __init__(
        self     ,
        location ,
        name     ,
    ):
        self._location = location
        self._name     = name
        self._chunks   = []
        return
    
    def add_code( self, code ):
        self._chunks.append( code )

#####

if __name__ == '__main__':
    main()
