#!/usr/bin/env python3

# everything is a lot easier if I give my callstack a little bit of state

# how to set gdb to step through assembly
# https://stackoverflow.com/questions/2420813/using-gdb-to-single-step-assembly-code-outside-specified-executable-causes-error

import sys
import os
import optparse

NUMBERS  = set( '0123456789' )
LETTERS  = set( 'abcdefghijklmnopqrstuvzwxyz' )

WORDSTART = LETTERS.union( set('_') )
WORDBITS  = LETTERS.union( NUMBERS ).union( '_-.' )

STRUCTBITS = ':;[]{}@'

def log( *args, **kwargs ):
    kwargs[ 'file' ] = sys.stderr
    print( *args, **kwargs )

def main():
    
    options, free = optparse.OptionParser().parse_args()
    if len( free ) != 1:
        raise Exception( 'usage: kmforth <path/to/file/to/compile>' )
    
    seen    = set()
    pending = [ FileSource(
        origin = '(main compilation target)' ,
        cwd    = os.getcwd()                 ,
        path   = free[0]                     ,
    )]
    
    allFns  = {}
    allDefs = []
    while pending:
        
        pp = pending.pop()
        
        incode      = pp.read_source()
        characters  = Source( parse_characters( data = incode, fileno = pp.fileno() ) )
        tokens      = Source( parse_tokens( characters = characters ) )
        definitions = Source( parse_definitions( tokens = tokens, currentModule = pp ) )
        
        functions, includes = categorize_definitions( definitions )
        
        for fn in functions:
            if functions[ fn ].name().value() in allFns:
                raise Exception( 'duplicate function: %s' % repr( fn ) )
            else:
                allFns[ functions[ fn ].name().value() ] = functions[ fn ]
        
        for inc in includes:
            norm = os.path.normpath( inc.path() )
            if norm not in seen:
                pending.append( inc )
                seen.add( norm )
    
    functions = analyze_functions( allFns )
    outcode   = generate_code( allFns )
    
    print( outcode )

class FileSource:
    
    NN = 0
    
    def __init__(
        self   ,
        origin ,
        cwd    ,
        path   ,
    ):
        self._fileno = self.NN
        self.NN += 1
        
        self._origin = origin
        self._cwd    = cwd
        self._path   = path
        return
    
    def fileno( self ):
        return self._fileno
    
    def is_function( self ):
        return False
    
    def is_include( self ):
        return True
    
    def path(
        self ,
    ):
        return os.path.join(
            self._cwd  ,
            self._path ,
        )
    
    def cwd_for_includes(
        self, 
    ):
        return os.path.dirname( self.path() )
    
    def read_source(
        self ,
    ):
        try:
            with open( self.path() ) as ff:
                data = ff.read()
                return data
        except Exception as ee:
            raise Exception( 'error reading path=%s %s: %s, %s' % (
                repr( self._path )  ,
                str( self._origin ) ,
                str( type( ee ) )   ,
                str( ee )           ,
            ))

class Source:
    def __init__(
        self   ,
        source ,
    ):
        self._iterator = iter( source )
        self._pending  = None
        self._done     = False
    
    def peek(
        self ,
    ):
        if self._done:
            return None
        elif self._pending == None:
            self._pending = next( self._iterator, None )
            if self._pending == None:
                self._done = True
        
        return self._pending
    
    def take(
        self ,
    ):
        vv = self.peek()
        self._pending = None
        return vv

class Character:
    def __init__(
        self      ,
        fileno    ,
        line      ,
        column    ,
        character ,
    ):
        self._fileno    = fileno
        self._line      = line
        self._column    = column
        self._character = character
        return
    
    def fileno    ( self ): return self._fileno
    def line      ( self ): return self._line
    def column    ( self ): return self._column
    def character ( self ): return self._character

class Token:
    def __init__(
        self   ,
        fileno ,
        line   ,
        column ,
        kind   ,
        value  ,
    ):
        self._fileno = fileno
        self._line   = line
        self._column = column
        self._kind   = kind
        self._value  = value
        return
    
    def fileno ( self ): return self._fileno
    def line   ( self ): return self._line
    def column ( self ): return self._column
    def kind   ( self ): return self._kind
    def value  ( self ): return self._value
    
    def __repr__( self ):
        return '<Token (%s:%s) kind=%s value=%s>' % (
            repr( self._line   ),
            repr( self._column ),
            repr( self._kind   ),
            repr( self._value  ),
        )

def parse_characters( data, fileno ):
    assert isinstance( data, str )
    
    line   = 1
    column = 0
    
    for cc in data:
        yield Character(
            fileno    = fileno ,
            line      = line   ,
            column    = column ,
            character = cc     ,
        )
        
        if cc == "\n":
            line += 1
            column = 0
        else:
            column += 1

def parse_tokens( characters ):
    
    while True:
        nc = characters.take()
        if not nc:
            break
        cc = nc.character()
        
        if cc == '#':
            discard_comment( characters = characters )
        
        elif cc in ' \n\t':
            discard_whitespace( characters = characters )
        
        elif cc == '"':
            yield extract_string( initial = nc, characters = characters )
            
        elif cc == "`":
            yield extract_code( initial = nc, characters = characters )
        
        elif cc == '-' or cc in NUMBERS:
            yield extract_number( initial = nc, characters = characters )
        
        elif cc.lower() in WORDSTART or cc == '$' or cc == '&':
            yield extract_word( initial = nc, characters = characters )
            
        elif cc.lower() in STRUCTBITS:
            yield Token(
                fileno = nc.fileno() ,
                line   = nc.line()   ,
                column = nc.column() ,
                kind   = cc.lower()  ,
                value  = None        ,
            )
        
        else:
            raise Exception( 'unknown character: %s' % repr( cc ) )

def discard_comment( characters ):
    while True:
        pc = characters.take()
        if not pc:
            break
        elif pc.character() == '\n':
            break
    return

def discard_whitespace( characters ):
    while True:
        pc = characters.peek()
        if not pc:
            break
        elif pc.character() in ' \t\n':
            characters.take()
        else:
            break
    return

def extract_string( initial, characters ):
    bits   = []
    escape = False
    while True:
        nc = characters.take()
        if not nc:
            raise Exception( 'unterminated string starting at: %s' % repr( initial ) )
        cc = nc.character()
        
        if escape:
            escape = False
            if cc == 'n':
                bits.append( '\n' )
                continue
            elif cc == '"':
                bits.append( '"' )
                continue
            else:
                raise Exception( 'unknown escape: %s' % repr( '\\' + cc ) )
        else:
            if cc == '"':
                break
            elif cc == "\\":
                escape = True
                continue
            else:
                bits.append( cc )
                continue
    
    return Token(
        fileno = initial.fileno()  ,
        line   = initial.line()   ,
        column = initial.column() ,
        kind   = 'string'         ,
        value  = ''.join( bits )  ,
    )

def extract_number( initial, characters ):
    bits = [ initial.character() ]
    while True:
        pc = characters.peek()
        if not pc:
            break
        cc = pc.character()
        if cc in '0123456789.':
            bits.append( cc )
            characters.take()
            continue
        else:
            break
    if '.' in bits:
        raise Exception( 'float not currently handled' )
    return Token(
        fileno  = initial.fileno() ,
        line    = initial.line()   ,
        column  = initial.column() ,
        kind    = 'integer'        ,
        value   = ''.join( bits )  ,
    )

def extract_code( initial, characters ):
    bits = []
    while True:
        pc = characters.take()
        if not pc:
            raise Exception( 'unterminated code segment starting at: %s' % repr( initial ) )
        cc = pc.character()
        if cc == '`':
            break
        else:
            bits.append( cc )
    return Token(
        fileno = initial.fileno() ,
        line   = initial.line()   ,
        column = initial.column() ,
        kind   = 'code'           ,
        value  = ''.join( bits )  ,
    )

def extract_word( initial, characters ):
    bits = [ initial.character() ]
    while True:
        pc = characters.peek()
        if not pc:
            break
        cc = pc.character()
        if cc.lower() in WORDBITS:
            characters.take()
            bits.append( cc )
        else:
            break
    if initial.character() == '$':
        kind  = 'localfn'
        value = ''.join(bits)
    elif initial.character() == '&':
        kind  = 'fnref'
        value = ''.join(bits)[1:]
    else:
        kind  = 'word'
        value = ''.join(bits)
        
    return Token(
        fileno = initial.fileno() ,
        line   = initial.line()   ,
        column = initial.column() ,
        kind   = kind             ,
        value  = value            ,
    )

def parse_definitions( tokens, currentModule ):
    while True:
        dd = parse_clause( tokens, currentModule )
        if dd == None:
            return
        else:
            yield dd

def parse_clause( tokens, currentModule ):
    initial = tokens.take()
    if not initial:
        return None
    elif initial.kind() == ':':
        return parse_named_function(
            initial = initial ,
            tokens  = tokens  ,
        )
    elif initial.kind() == '@':
        return parse_include(
            initial       = initial       ,
            tokens        = tokens        ,
            currentModule = currentModule ,
        )
    else:
        raise Exception( 'expected ":" at head of definition, found: %s:' % repr( initial ) )

def parse_named_function( initial, tokens ):
    
    name = tokens.take()
    if not name:
        raise Exception( 'expected name of definition after %s, found end of data' % repr( initial ) )
    elif name.kind() == 'word':
        pass
    else:
        raise Exception( 'expected name of definition after %s, found: %s' % ( repr( initial ), repr( name ) ) )
    
    body = parse_body( initial, tokens )
    
    ct = tokens.take()
    if ct == None:
        raise Exception( 'expected ";" after %s' % repr( initial ) )
    elif ct.kind() != ';':
        raise Exception( 'expected ";" after %s, found %s' % ( repr( initial ), repr( ct ) ) )
    
    return NamedFunction(
        fileno = initial.fileno() ,
        line   = initial.line()   ,
        column = initial.column() ,
        name   = name             ,
        body   = body             ,
    )

def parse_lambda_definition( initial, tokens ):
    body = parse_body( initial, tokens )
    return LambdaFunction(
        fileno = initial.fileno() ,
        line   = initial.line()   ,
        column = initial.column() ,
        body   = body             ,
    )

def parse_body( initial, tokens ):
    
    localfns = parse_optional_locals( tokens )
    
    commands = []
    subfns   = []
    while True:
        pt = tokens.peek()
        if not pt:
            break
        elif pt.kind() == ';':
            break
        elif pt.kind() == ']':
            break
        elif pt.kind() == '[':
            tokens.take()
            subfntoks = []
            depth = 0
            while True:
                st = tokens.take()
                if st == None:
                    raise Exception( 'expected "]" following unclosed %s' % repr( pt ) )
                elif st.kind() == ']':
                    if depth == 0:
                        break
                    else:
                        depth -= 1
                        subfntoks.append( st )
                elif st.kind() == '[':
                    depth += 1
                    subfntoks.append( st )
                else:
                    subfntoks.append( st )
            subfn = parse_lambda_definition(
                initial = pt                  ,
                tokens  = Source( subfntoks ) ,
            )
            subfns.append( subfn )
            commands.append( Token(
                fileno = subfn.fileno()       ,
                line   = subfn.line()         ,
                column = subfn.column()       ,
                kind   = 'subfn'              ,
                value  = subfn.name().value() ,
            ))
        elif pt.kind() == 'word':
            tokens.take()
            commands.append( Token(
                fileno = pt.fileno()          ,
                line   = pt.line()            ,
                column = pt.column()          ,
                kind   = 'word'               ,
                value  = 'kmfn_' + pt.value() ,
            ))
        elif pt.kind() == 'fnref':
            tokens.take()
            commands.append( Token(
                fileno = pt.fileno()          ,
                line   = pt.line()            ,
                column = pt.column()          ,
                kind   = 'fnref'              ,
                value  = 'kmfn_' + pt.value() ,
            ))
        
        elif pt.kind() in [ 'localfn', 'string', 'integer', 'code' ]:
            tokens.take()
            commands.append( pt )
        else:
            raise Exception( 'what is %s' % repr( pt ) )
    
    return Body(
        fileno   = initial.fileno() ,
        line     = initial.line()   ,
        column   = initial.column() ,
        commands = commands         ,
        localfns = localfns         ,
        subfns   = subfns           ,
    )

def parse_optional_locals( tokens ):
    pt = tokens.peek()
    if not pt:
        return []
    elif pt.kind() != '{':
        return []
    else:
        tokens.take()
    
    seen       = set()
    localNames = []
    
    while True:
        pt = tokens.peek()
        if pt == None:
            break
        elif pt.kind() != 'localfn':
            break
        else:
            tokens.take()
            if '.' in pt.value():
                raise Exception( 'localfn name declarations cannot include a period (.): %s' % repr( pt ) )
            elif pt.value() in seen:
                raise Exception( 'duplicate localfn name declaration: %s' % repr( pt ) )
            else:
                seen.add( pt.value() )
                localNames.append( pt.value() )
    
    ct = tokens.take()
    if not ct:
        raise Exception( 'expected } following: %s' % repr( pt ) )
    elif ct.kind() != '}':
        raise Exception( 'expected } following %s, found %s' % ( repr( pt ), repr( ct ) ) )
    
    return localNames

class NamedFunction:
    def __init__(
        self   ,
        fileno ,
        line   ,
        column ,
        name   ,
        body   ,
    ):
        self._fileno = fileno
        self._line   = line
        self._column = column
        self._name   = name
        self._body   = body
        return
    
    def __repr__( self ):
        return '<NamedFunction name=%s commands=%s>' % (
            repr( self._name.value() ) ,
            repr( len( self._body.commands() ) ) ,
        )
    
    def is_function( self ): return True
    
    def fileno ( self ): return self._fileno
    def line   ( self ): return self._line
    def column ( self ): return self._column
    def body   ( self ): return self._body
    
    def name( self ):
        return Token(
            fileno = self._name.fileno()          ,
            line   = self._name.line()            ,
            column = self._name.column()          ,
            kind   = 'word'                       ,
            value  = 'kmfn_' + self._name.value() ,
        )

class LambdaFunction:
    def __init__(
        self   ,
        fileno ,
        line   ,
        column ,
        body   ,
    ):
        self._fileno = fileno
        self._line   = line
        self._column = column
        self._body   = body
        return
    
    def __repr__( self ):
        return '<LambdaFunction (%d:%d:%d) commands=%d>' % (
            self._fileno                 ,
            self._line                   ,
            self._column                 ,
            len( self._body.commands() ) ,
        )
    
    def fileno ( self ): return self._fileno
    def line   ( self ): return self._line
    def column ( self ): return self._column
    def body   ( self ): return self._body
    
    def name( self ):
        return Token(
            fileno = self._fileno ,
            line   = self._line   ,
            column = self._column ,
            kind   = 'word'       ,
            value  = 'kmlambda_%s_%s_%s' % (
                str( self._fileno ),
                str( self._line   ),
                str( self._column ),
            ),
        )

class Body:
    
    def __init__(
        self     ,
        fileno   ,
        line     ,
        column   ,
        commands ,
        localfns ,
        subfns   ,
    ):
        self._fileno   = fileno
        self._line     = line
        self._column   = column
        self._commands = commands
        self._localfns = localfns
        self._subfns   = subfns
        return
    
    def is_function ( self ): return True
    def is_include  ( self ): return False
    
    def __repr__( self ):
        return '<Definition (%s:%s) command.cnt=%s>' % (
            repr( self._line            ),
            repr( self._column          ),
            repr( len( self._commands ) ),
        )
    
    def fileno   ( self ): return self._fileno
    def line     ( self ): return self._line
    def column   ( self ): return self._column
    def commands ( self ): return self._commands
    def nlocals  ( self ): return len( self._localfns )
    def localfns ( self ): return self._localfns
        
    def subfns( self ):
        return self._subfns
    
    def get_localfn_slotno(
        self ,
        name ,
    ):
        try:
            return self._localfns.index( name )
        except ValueError:
            # item not found
            return None

def parse_include( initial, tokens, currentModule ):
    path = tokens.take()
    if path == None:
        raise Exception( 'found nothing while expecting path after: %s' % repr( initial ) )
    
    if path.kind() != 'string':
        raise Exception( 'expected path after @, found %s' % repr( path ) )
    
    end = tokens.take()
    if end == None:
        raise Exception( 'found nothing while expecting ";" after: %s' % repr( path ) )
    
    if end.kind() != ';':
        raise Exception( 'expected ; after path, found %s' % repr( end ) )
    
    return FileSource(
        origin = '(included from file=%s)' % currentModule.path() ,
        cwd    = currentModule.cwd_for_includes()                 ,
        path   = path.value()                                     ,
    )

#####

def categorize_definitions( definitions ):
    fns = {}
    ins = {}
    while True:
        dd = definitions.take()
        if dd == None:
            break
        
        if dd.is_function():
            pending = [ dd ]
            while pending:
                nn = pending.pop(0)
                if nn.name().value() in fns:
                    raise Exception( 'duplicate function name: %s' % nn.name() )
                fns[ nn.name().value() ] = nn
                
                for subfn in nn.body().subfns():
                    pending.append( subfn )
        
        elif dd.is_include():
            if dd.path() not in ins:
                ins[ dd.path() ] = dd
        
        else:
            raise Exception( 'unknown definition type: %s' % repr( dd ) )
    
    return fns, list( ins.values() )

def analyze_functions( fns ):
    for dd in fns.values():
        for cc in dd.body().commands():
            if cc.kind() == 'word':
                if (cc.value()) not in fns:
                    raise Exception( 'unknown function in %s: %s' % ( repr( dd ), repr( cc ) ) )
            elif cc.kind() == 'string':
                pass
            elif cc.kind() == 'code':
                pass
            elif cc.kind() == 'integer':
                pass
            elif cc.kind() == 'localfn':
                pass
            elif cc.kind() == 'fnref':
                if cc.value() not in fns:
                    raise Exception( 'unknown function in %s: %s' % ( repr( dd ), repr( cc ) ) )
            elif cc.kind() == 'subfn':
                if cc.value() not in fns:
                    raise Exception( 'missing lambda in %s: %s' % ( repr( dd ), repr( cc ) ) )
            else:
                raise Exception( 'unexpected command form: %s' % repr( cc ) )
    
    return fns

#####

# returnindex + 1
# newframe = stack + sizeof( returnframe = 16) * returnindex
# newframe[0] = fn_0
# newframe[1] = 0
# goto command

def generate_code( functions ):
    
    staticStrings = set()
    
    pre  = []
    data = []
    code = []
    bss  = []
    
    nns = 0
    
    bss.append( 'section .bss\n' )
    bss.append( 'datastack: resq 1\n' )
    bss.append( 'callstack: resq 1\n' )
    bss.append( '\n' )
    
    data.append( 'section .data\n' )
    data.append( '\n' )
    
    code.append( 'section .text\n' )
    
    code.append( 'global _start\n')
    code.append( '_start:\n' )
    code.append( '    jmp kmfn__start\n' )
    code.append( '\n')
    
    nn = 0
    for fn in functions:
        code.append( '\n' )
        code.append( '  ' + fn + ':\n' )
        
        if functions[ fn ].body().nlocals():
            code.append( '  ; make space for any locals\n' )
            code.append( '  add r15, %d\n' % ( functions[ fn ].body().nlocals() * 8 ) )
        
        for command in functions[ fn ].body().commands():
            
            if command.kind() == 'word':
                rt = fn + '_' + str( nn )
                nn = nn + 1
                
                code.append( '    ; calling %s\n' % command.value() )
                code.append( '    mov qword [r15], %s\n' % rt )
                code.append( '    add r15, 8\n' )
                code.append( '    jmp ' + command.value() + '\n' )
                code.append( '  %s:\n' % rt )
                
            elif command.kind() == 'code':
                code.append( '\n' )
                code.append( '; including code literal\n' )
                code.append( command.value() )
                code.append( '\n' )
                
            elif command.kind() == 'string':
                
                if "'" in command.value():
                    raise Exception( 'need a more robust implementation' )
                
                sn = "km_c_" + str(nns)
                nns += 1
                data.append( '  ' + sn + ':\n' )
                # convert \n into 10 here ( 10, 13 for windows, but fuck those guys
                data.append( "    db %s\n" % asm_stringize( command.value() ) )
                
                code.append( '   ; pushing string literal %s\n' % repr( command.value() ) )
                code.append( '   mov qword [r14], %s\n' % sn )
                code.append( '   add r14, 8\n' )
                
            elif command.kind() == 'integer':
                code.append( '   mov qword [r14], %s\n' % command.value() )
                code.append( '   add r14, 8\n' )
            
            elif command.kind() == 'localfn':
                if command.value().startswith('$.'):
                    builtin = command.value()
                    if builtin == '$.callIf':
                        label = '.km_nocall_' + str(nns)
                        nns += 1
                        code.append( '    ; callIf localfn\n' )
                        code.append( '    sub r14, 8\n' )
                        code.append( '    mov rax, [r14]\n' )
                        code.append( '    sub r14, 8\n' )
                        code.append( '    mov rbx, [r14]\n' )
                        code.append( '    test rax,rax\n' )
                        code.append( '    jz %s\n' % label )
                        code.append( '    mov qword [r15], %s\n' % label )
                        code.append( '    add r15, 8\n' )
                        code.append( '    jmp rbx\n' )
                        code.append( '   %s:\n' % label )
                    elif builtin == '$.jumpIf':
                        label = '.km_nojump_' + str(nns)
                        nns += 1
                        code.append( '    ; jumpIf \n' )
                        code.append( '    sub r14, 8\n' )
                        code.append( '    mov rax, [r14]\n' )
                        code.append( '    sub r14, 8\n' )
                        code.append( '    mov rbx, [r14]\n' )
                        code.append( '    test rax,rax\n' )
                        code.append( '    jz %s\n' % label )
                        code.append( '    jmp rbx\n' )
                        code.append( '   %s:\n' % label )
                    elif builtin == '$.leaveIf':
                        label = '.km_noleave_' + str(nns)
                        nns += 1
                        code.append( '    ; leaveIf\n' )
                        code.append( '    sub r14, 8\n' )
                        code.append( '    mov rax, [r14]\n' )
                        code.append( '    test rax,rax\n' )
                        code.append( '    jz %s\n' % label )
                        if functions[ fn ].body().nlocals():
                            code.append( '    ; (popping locals before leaving)\n' )
                            code.append( '    sub r15, %d\n' % ( functions[fn].body().nlocals() * 8 ) )
                        code.append( '    sub r15, 8\n' )
                        code.append( '    jmp [r15]\n' )
                        code.append( '   %s:\n' % label )
                    else:
                        raise Exception( 'unknown builtin localfn: %s' % repr( command.value() ) )
                else:
                    # locals getters and setters
                    localName, memberfn = command.value().split('.',1)
                    slotno = functions[ fn ].body().get_localfn_slotno( localName )
                    if slotno == None:
                        raise Exception( 'failed to find local %s in function %s' % ( repr( localName ), repr( fn ) ) )
                    if memberfn == 'get':
                        code.append( '    ; push local (%s) to datastack\n' % repr( localName ) )
                        code.append( '    mov rax, [r15-8*%d]\n' % (slotno+1) )
                        code.append( '    mov qword [r14], rax\n' )
                        code.append( '    add r14, 8\n' )
                    elif memberfn == 'set':
                        code.append( '    ; pop datastack storing to local (%s)\n' % ( repr( localName ) ) )
                        code.append( '    sub r14, 8\n' )
                        code.append( '    mov rax, [r14]\n' )
                        code.append( '    mov qword [r15-8*%d], rax\n' % (slotno+1) )
                    elif memberfn == 'here':
                        label = 'km_here_' + str(nns)
                        nns += 1
                        code.append( '    ; set local to label following this command\n' )
                        code.append( '    mov qword [r15-8*%d], %s\n' % ( (slotno+1), label) )
                        code.append( '    %s:\n' % label )
                    else:
                        raise Exception( 'unknown localfn ( expecting <local>.get or <local>.set ): %s' % repr( command.value() ) )
                    
            elif command.kind() == 'fnref':
                code.append( '    ; push reference to fn\n' )
                code.append( '    mov qword [r14], %s\n' % command.value() )
                code.append( '    add r14, 8\n' )
                
            elif command.kind() == 'subfn':
                code.append( '    ; push subfn reference\n' )
                code.append( '    mov qword [r14], %s\n' % command.value() )
                code.append( '    add r14, 8\n' )
                
            else:
                raise Exception( 'wat %s %s' % ( str( command.kind() ), repr( command.value() ) ) )
        
        if functions[ fn ].body().nlocals():
            code.append( '    ; pop any locals\n' )
            code.append( '    sub r15, %d\n' % ( functions[ fn ].body().nlocals() * 8 ) )
            
        code.append( '    sub r15, 8\n' )
        code.append( '    jmp [r15]\n' )
        
    return '\n'.join( [''.join(pre), ''.join( data ), ''.join( code ), ''.join( bss ) ] )
    
def asm_stringize( ss ):
    bits      = []
    instr     = False
    for cc in ss:
        if cc.lower() in ' abcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()[]{}|,':
            if instr:
                bits.append( cc )
                continue
            else:
                if bits:
                    bits.append( ',' )
                bits.append( "'" )
                bits.append( cc )
                instr = True
        else:
            if instr:
                bits.append( "'")
                instr = False
            first = None
            for bit in cc.encode('utf-8').hex():
                if first == None:
                    first = bit
                else:
                    if bits:
                        bits.append( ',' )
                    bits.append( '0x' + first + bit )
                    first = None
    if instr:
        bits.append( "'" )
    
    if bits:
        bits.append(',')
    
    bits.append( '0' )
    
    return ''.join( bits )
    
#####

if __name__ == '__main__':
    main()
